<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="google-site-verification" content="6jvcY_UrCpp1JLjXITf45ljboLU0NDGF16ZqomMt-ls">
  
  <title>个人笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="随笔">
<meta property="og:type" content="website">
<meta property="og:title" content="个人笔记">
<meta property="og:url" content="http://blog.kimq.cn/page/4/index.html">
<meta property="og:site_name" content="个人笔记">
<meta property="og:description" content="随笔">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人笔记">
<meta name="twitter:description" content="随笔">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>
</html>
<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
          <li><a class=""
                 href="/atom.xml">Rss</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">个人笔记</h1>
  
    <p class="lead blog-description">专注互联网</p>
  
</div>

    <div class="row">
        <div class="col-sm-9 blog-main">
          
  
    <article id="post-cgi_web-server" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/22/cgi_web-server/">CGI网关服务器漫谈</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/22/cgi_web-server/" class="article-date"><time datetime="2017-07-22T13:50:49.000Z" itemprop="datePublished">2017-07-22</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/后端/">后端</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>作为一名C/C++转后端的程序员，习惯于socket的裸（<em>在tcp/ip下面操作系统还隐藏了很多细节，这里姑且不论</em>），会纠结一个问题，为什么python还需要wsgi服务器夹在中间呢？</p>
<p>在一个web请求到达实际的业务逻辑，需要（但不限于）经过</p>
<ol>
<li>处理tcp连接，读写二进制数据</li>
<li>解析http协议，并判断合法性</li>
<li>检查参数合法性</li>
<li>检查权限/访问控制</li>
<li>安全防护检查</li>
<li>特定语言的参数序列化（绑定）</li>
</ol>
<p>而业务逻辑处理之后，又需要（但不限于）经过</p>
<ol>
<li>反序列化数据（比如对象转json/xml）</li>
<li>格式化输出（比如html模板引擎）</li>
</ol>
<p>除了各种中间服务器，还有各种web框架，例如Python <a href="http://flask.pocoo.org/" target="_blank" rel="noopener">flask</a>等</p>
<p>对于socket处理，Http(s)协议解析，<a href="https://nginx.org/en/" target="_blank" rel="noopener">nginx</a>/<a href="http://httpd.apache.org/" target="_blank" rel="noopener">apache</a>等成熟服务器是强项，由于是通用的服务器，并不会和特定的语言绑定，所以要和用特定程序语言实现的web业务逻辑配合工作，就需要一定的协议来交互，这就产生了CGI。</p>
<p>并不是所有的后端语言都需要独立服务器来配合处理网络和http协议，Golang就是一个例外，Golang内置的<a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener">Http库</a>非常完善（也有很高效的第三方库，比如<a href="https://github.com/valyala/fasthttp" target="_blank" rel="noopener">fasthttp</a>），所以Go web框架大都把这块直接包进去了。</p>
<blockquote>
<p>这种做法在部署上有更好的灵活性和便捷性，特别是配合<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>，对比<a href="https://projects.spring.io/spring-boot/" target="_blank" rel="noopener">spring boot</a>打包<a href="http://www.eclipse.org/jetty/" target="_blank" rel="noopener">jetty</a>直接运行</p>
</blockquote>
<p>对于其他语言，例如python,通常会采用Http <--> WSGI <--> WEB框架 <--> 业务代码 的方式</--></--></--></p>
<blockquote>
<p>并非python无法实现类似与Golang的大一统集成方案，理论上什么语言都是可行的，不过基于性能上的考虑，或者避免重复造轮子等。</p>
</blockquote>
<p>这种方案利用了各自的优势，协同完成整个事情，但他们并非物理分割的实体，比如<a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener">uWSGI</a>或者<a href="http://gunicorn.org/" target="_blank" rel="noopener">gunicorn</a>就实现了http服务器和wsgi协议处理，</p>
<p>在很多文章中，例如【<a href="http://www.jianshu.com/p/84978157c785" target="_blank" rel="noopener">Flask+uwsgi+Nginx</a>】，会再附加一个nginx在最前面，这更多的是为了扩展其他一些功能，比如</p>
<ol>
<li>反向代理</li>
<li>负责均衡</li>
<li>代理静态资源</li>
<li>https</li>
<li>…</li>
</ol>
<blockquote>
<p>nginx负载均衡在应用层处理，在一些高性能场景，可能需要特殊定制的负载均衡服务器，直接在内核的ip层/数据链路层作处理</p>
</blockquote>
<p>scgi的一个简单实现如<a href="https://docs.python.org/2/library/wsgiref.html#module-wsgiref.simple_server" target="_blank" rel="noopener">wsgiref.simple_server</a>，基于它很容易写出一个简单的<a href="http://blog.ez2learn.com/2010/01/27/introduction-to-wsgi/" target="_blank" rel="noopener">Python web程序</a>，或者扩展成一个web框架</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""a simple wsgi application"""</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">u"你好! 歡迎來到Victor的第一個WSGI程式"</span>.encode(<span class="string">'utf8'</span>)]</span><br><span class="line"></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">8000</span>, my_app)</span><br><span class="line">print(<span class="string">"Serving on port 8000..."</span>)</span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<p>借助<a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener">uWSGI</a>也很<a href="http://www.bjhee.com/nginx-uwsgi.html" target="_blank" rel="noopener">容易实现</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    output = <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>),</span><br><span class="line">                        (<span class="string">'Content-Length'</span>, str(len(output)))]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [output]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install uwsgi</span><br><span class="line">king@king:~/code/bug$ uwsgi --version</span><br><span class="line">2.0.15</span><br><span class="line">king@king:~/code/bug$ uwsgi --http :9090 --wsgi-file server.py</span><br></pre></td></tr></table></figure>
<p>wcgi利用了语言的特性，直接通过调用和回调的方式实现高效请求转发和回传，wcgi和业务代码就在同个进程中，而最早的cgi并非这样</p>
<p>最早的<a href="https://shenwang.blog.ustc.edu.cn/nginx%E5%92%8Cuwsgi%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">CGI</a>是很灵活的，收到请求后CGI网关会启动子进程，并通过IPC（通常的做法是将stdin/stdout对接到输入输出）发送请求和接收结果，处理完成，子进程退出。</p>
<p>nging配置cgi比较繁琐，可以通过nc来<a href="http://qjw.qiujinwu.com/blog/2013/12/22/nc_server" target="_blank" rel="noopener">模拟一些这个流程</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf_[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gets(buf_))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recv : %s\n"</span>,buf_);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>server<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:/tmp$ gcc a.c</span><br><span class="line">king@king:/tmp$ rm -f /tmp/f; mkfifo /tmp/f</span><br><span class="line">king@king:/tmp$ cat /tmp/f | ./a.out | nc -l -p 12345 127.0.0.1 &gt; /tmp/f</span><br></pre></td></tr></table></figure></p>
<p>client<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:/tmp$ nc 127.0.0.1 12345</span><br><span class="line">1</span><br><span class="line">recv : 1</span><br><span class="line">2</span><br><span class="line">recv : 2</span><br><span class="line">3</span><br><span class="line">recv : 3</span><br><span class="line">4</span><br><span class="line">recv : 4</span><br><span class="line">5</span><br><span class="line">recv : 5</span><br><span class="line">6</span><br><span class="line">recv : 6</span><br></pre></td></tr></table></figure></p>
<p>CGI的设计可以支持各种不同语言的程序，问题是性能太差，所以又搞出了什么fastcgi。</p>
<p>FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。这其中又以Php的<a href="https://php-fpm.org/" target="_blank" rel="noopener">PHP-FPM</a>比较典型，和Python的网关服务器将Http协议处理部分自行处理不同，Php网关服务器通常配合第三方Http服务器使用，例如<a href="https://nginx.org/en/" target="_blank" rel="noopener">nginx</a>或者<a href="https://www.lighttpd.net/" target="_blank" rel="noopener">lighttpd</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/20694204" target="_blank" rel="noopener">PHP-FPM</a>作为一个独立的网关服务器存在，和nginx类似，会有一个master进程接收请求（nginx的master进程做的事情少得多）和若干worker进程，每个worker进程会跑一个PHP解释器，是 PHP 代码真正执行的地方。master进程则监听端口，并接收来自Http服务器的请求，通常情况下使用unixsocket。</p>
<p>nginx作为一个通用的服务器，为了配合<a href="https://php-fpm.org/" target="_blank" rel="noopener">PHP-FPM</a>，需要使用插件<a href="https://www.nginx.com/resources/wiki/start/topics/examples/phpfcgi/" target="_blank" rel="noopener">fastcgi_param</a>，根据配置该插件会作一些转换并请求代理到FPM的地址。</p>
<p>处理好了Http请求分析，调度传递之后，还有很多事情需要处理，如前面提到的【检查参数合法性】、【检查权限/访问控制】等，这就是web框架的事情了，web框架是为了提高开发效率，让开发者更聚焦于业务逻辑，直接裸写也是OK的。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/22/cgi_web-server/" data-id="ckdbgbyv9000943po7cr7k452" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/22/cgi_web-server/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wcgi/">wcgi</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-ssl" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/14/ssl/">证书与Nginx部署</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/14/ssl/" class="article-date"><time datetime="2017-07-14T13:04:43.000Z" itemprop="datePublished">2017-07-14</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/后端/">后端</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="证书类别"><a href="#证书类别" class="headerlink" title="证书类别"></a>证书类别</h1><p>按照审核方式，一般的CA机构提供三种类型的SSL证书：域名型SSL(DV SSL)，企业型SSL(OV SSL)以及增强型SSL(EV SSL)证书。</p>
<p>三种证书底层的技术实现是一致的，区别在于证书发布方对申请方的审核程度，在证书的<strong>颁发对象</strong>中有很多字段，比如</p>
<ol>
<li>CN Common Name</li>
<li>OU Organization Unit</li>
<li>O Organization Name</li>
<li>L Locality</li>
<li>S State/Provice</li>
<li>C Country</li>
</ol>
<p>一个典型的EV证书颁发对象（工商银行）,可以看到各种字段非常详尽<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CN = corporbank-simp.icbc.com.cn</span><br><span class="line">OU = Software Development Center</span><br><span class="line">O = Industrial and Commercial Bank of China Limited</span><br><span class="line">STREET = NO.55 Fuxingmen Nei Street Xicheng District, Beijing</span><br><span class="line">L = Beijing</span><br><span class="line">S = Beijing</span><br><span class="line">PostalCode = 100140</span><br><span class="line">C = CN</span><br><span class="line">SERIALNUMBER = 100000000003965</span><br><span class="line">2.5.4.15 = Private Organization</span><br><span class="line">1.3.6.1.4.1.311.60.2.1.2 = BEIJING</span><br><span class="line">1.3.6.1.4.1.311.60.2.1.3 = CN</span><br></pre></td></tr></table></figure></p>
<p>百度的OV证书<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CN = baidu.com</span><br><span class="line">OU = service operation department.</span><br><span class="line">O = BeiJing Baidu Netcom Science Technology Co., Ltd</span><br><span class="line">L = beijing</span><br><span class="line">S = beijing</span><br><span class="line">C = CN</span><br></pre></td></tr></table></figure></p>
<p>在腾讯云上申请的DV证书，就剩下可怜的一行，这种免费证书不支持多域名和泛域名（比如*.qiujinwu.com），只能写死某个域名。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CN = ycy.qiujinwu.com</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/" target="_blank" rel="noopener">关于证书的支持范围</a></p>
<table>
<thead>
<tr>
<th></th>
<th>单域名</th>
<th>多域名</th>
<th>泛域名</th>
<th>多泛域名</th>
</tr>
</thead>
<tbody>
<tr>
<td>DV</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>OV</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>EV</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>举例</td>
<td><a href="http://www.barretlee.com" target="_blank" rel="noopener">www.barretlee.com</a></td>
<td><a href="http://www.barretlee.com" target="_blank" rel="noopener">www.barretlee.com</a> <br><a href="http://www.xiaohuzige.com" target="_blank" rel="noopener">www.xiaohuzige.com</a> <br><a href="http://www.barret.cc" target="_blank" rel="noopener">www.barret.cc</a></td>
<td>*.barretlee.com</td>
<td><em>.barretlee.com <br> </em>.xiaohuzige.com <br>*.barret.cc</td>
</tr>
</tbody>
</table>
<h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>配置服务器证书即可，实现Https的访问，对于上面的免费DV证书，就可以实现全网的可信任Https</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /tmp/a/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /tmp/a/server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span>    shared:SSL:<span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自建CA"><a href="#自建CA" class="headerlink" title="自建CA"></a>自建CA</h1><p>证书支持一个树状的层级认证链关系，例如Google首页的证书<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Builtin Object Token:GeoTrust Global CA</span><br><span class="line">  Google Internet Authority G2</span><br><span class="line">    *.google.com.hk</span><br></pre></td></tr></table></figure></p>
<p>按照通行的做法，会建多级ca，一个root ca和若干个和若干层intermediate ca，然后再一堆的服务器/客户端证书，此内容重点参考<a href="http://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/" target="_blank" rel="noopener">http://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/</a></p>
<h2 id="工具shell"><a href="#工具shell" class="headerlink" title="工具shell"></a>工具shell</h2><p>由于创建公私钥，证书、签名的过程需要输入密码等各种参数，为了方便测试，下面的脚本进行了封装，支持批量化运行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 常用后缀</span></span><br><span class="line">key=<span class="string">".key"</span> <span class="comment"># 私（公）钥</span></span><br><span class="line">crt=<span class="string">".crt"</span> <span class="comment"># 证书</span></span><br><span class="line">csr=<span class="string">".csr"</span> <span class="comment"># 证书签名请求</span></span><br><span class="line">p12=<span class="string">".p12"</span> <span class="comment"># 打包了私钥的证书</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建私（公）钥</span></span><br><span class="line"><span class="function"><span class="title">create_key</span></span>()&#123;</span><br><span class="line">    <span class="comment"># 加密方式，可以但不限这些，</span></span><br><span class="line">    <span class="comment"># aes256/des3/aes128</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2048 可以作为参数，亦可调整大小</span></span><br><span class="line">    name=<span class="string">"<span class="variable">$&#123;1&#125;</span><span class="variable">$&#123;key&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;#&#125;</span>"</span> -gt 1 ];<span class="keyword">then</span></span><br><span class="line">        openssl genrsa -aes256 -passout pass:<span class="variable">$&#123;2&#125;</span> -out <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> 2048</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment"># 不填写参数则无密码</span></span><br><span class="line">        openssl genrsa -out <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> 2048</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除私（公）钥的密码</span></span><br><span class="line"><span class="function"><span class="title">remove_key_pwd</span></span>()&#123;</span><br><span class="line">    <span class="comment"># notify passin &amp; passout</span></span><br><span class="line">    name=<span class="string">"<span class="variable">$&#123;1&#125;</span><span class="variable">$&#123;key&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;#&#125;</span>"</span> -gt 1 ];<span class="keyword">then</span></span><br><span class="line">        openssl rsa -<span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> -passin pass:<span class="string">"<span class="variable">$&#123;2&#125;</span>"</span> -out <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        openssl rsa -<span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> -out <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出证书详情</span></span><br><span class="line"><span class="function"><span class="title">check_crt</span></span>()&#123;</span><br><span class="line">    openssl x509 -noout -text -<span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;1&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于测试，SUJECT作为一个全局的参数存在，除了Common Name</span></span><br><span class="line">C=<span class="string">"CN"</span></span><br><span class="line">ST=<span class="string">"GD"</span></span><br><span class="line">L=<span class="string">"SZ"</span></span><br><span class="line">O=<span class="string">"0MyCompany"</span></span><br><span class="line">OU=<span class="string">"Department"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自签名</span></span><br><span class="line"><span class="function"><span class="title">self_sign</span></span>()&#123;</span><br><span class="line">	<span class="comment"># SUJECT 的Common Name</span></span><br><span class="line">    common_name=<span class="variable">$1</span></span><br><span class="line">    output=<span class="variable">$2</span></span><br><span class="line">    <span class="comment"># 是否输入了密码</span></span><br><span class="line">    password_param=<span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;#&#125;</span>"</span> -gt 2 ];<span class="keyword">then</span></span><br><span class="line">        password_param=<span class="string">"-passin pass:<span class="variable">$&#123;3&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    SUBJECT=<span class="string">"/C=<span class="variable">$&#123;C&#125;</span>/ST=<span class="variable">$&#123;ST&#125;</span>/L=<span class="variable">$&#123;L&#125;</span>/O=<span class="variable">$&#123;O&#125;</span>/OU=<span class="variable">$&#123;OU&#125;</span>/CN=<span class="variable">$&#123;common_name&#125;</span>"</span></span><br><span class="line">    <span class="comment"># 留意-config -extensions</span></span><br><span class="line">    openssl req -config `<span class="built_in">pwd</span>`/ca_openssl.cnf \</span><br><span class="line">        <span class="variable">$&#123;password_param&#125;</span> -subj <span class="variable">$&#123;SUBJECT&#125;</span>  \</span><br><span class="line">        -extensions v3_ca \</span><br><span class="line">        -key <span class="string">"<span class="variable">$&#123;output&#125;</span><span class="variable">$&#123;key&#125;</span>"</span> -new -x509 \</span><br><span class="line">        -days 7200 -sha256 -out <span class="string">"<span class="variable">$&#123;output&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建证书签名请求</span></span><br><span class="line"><span class="function"><span class="title">create_csr</span></span>()&#123;</span><br><span class="line">	<span class="comment"># SUJECT 的Common Name</span></span><br><span class="line">    common_name=<span class="variable">$1</span></span><br><span class="line">    output=<span class="variable">$2</span></span><br><span class="line">    <span class="comment"># 和函数self_sign一样</span></span><br><span class="line">    SUBJECT=<span class="string">"/C=<span class="variable">$&#123;C&#125;</span>/ST=<span class="variable">$&#123;ST&#125;</span>/L=<span class="variable">$&#123;L&#125;</span>/O=<span class="variable">$&#123;O&#125;</span>/OU=<span class="variable">$&#123;OU&#125;</span>/CN=<span class="variable">$&#123;common_name&#125;</span>"</span></span><br><span class="line">    <span class="comment"># 是否输入了密码</span></span><br><span class="line">    password_param=<span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;#&#125;</span>"</span> -gt 2 ];<span class="keyword">then</span></span><br><span class="line">        password_param=<span class="string">"-passin pass:<span class="variable">$&#123;3&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># 留意-config -extensions</span></span><br><span class="line">    openssl req -config `<span class="built_in">pwd</span>`/imm_openssl.cnf <span class="variable">$&#123;password_param&#125;</span> -new -sha256 -subj <span class="variable">$&#123;SUBJECT&#125;</span> \</span><br><span class="line">        -key <span class="string">"<span class="variable">$&#123;output&#125;</span><span class="variable">$&#123;key&#125;</span>"</span> -out <span class="string">"<span class="variable">$&#123;output&#125;</span><span class="variable">$&#123;csr&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ca签名，包括root ca给intermediate签名，以及intermediate ca和业务证书签名</span></span><br><span class="line"><span class="function"><span class="title">ca_sign</span></span>()&#123;</span><br><span class="line">    input=<span class="variable">$1</span></span><br><span class="line">    cafile=<span class="variable">$2</span></span><br><span class="line">    <span class="comment"># 是否输入了密码</span></span><br><span class="line">    password_param=<span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;#&#125;</span>"</span> -gt 2 ];<span class="keyword">then</span></span><br><span class="line">        password_param=<span class="string">"-passin pass:<span class="variable">$&#123;3&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    extensionsparam=<span class="string">""</span></span><br><span class="line">    cnfparam=<span class="string">"-config `pwd`/imm_openssl.cnf"</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;cafile&#125;</span>"</span> == <span class="string">"ca"</span> ];<span class="keyword">then</span></span><br><span class="line">    	<span class="comment"># root ca签名的情形，使用ca_openssl.cnf，以及指定extensions</span></span><br><span class="line">        cnfparam=<span class="string">"-config `pwd`/ca_openssl.cnf"</span></span><br><span class="line">        extensionsparam=<span class="string">"-extensions v3_intermediate_ca"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -batch without （Y/N）prompt</span></span><br><span class="line">    openssl ca <span class="variable">$&#123;cnfparam&#125;</span> <span class="variable">$&#123;password_param&#125;</span> <span class="variable">$&#123;extensionsparam&#125;</span> \</span><br><span class="line">        -batch -days 3600 -notext -md sha256 \</span><br><span class="line">        -<span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;input&#125;</span><span class="variable">$&#123;csr&#125;</span>"</span> -out <span class="string">"<span class="variable">$&#123;input&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span> <span class="comment">#\</span></span><br><span class="line">        <span class="comment"># 由于使用了conf指定ca，这些参数是多余的</span></span><br><span class="line">        <span class="comment">#-cert "$&#123;cafile&#125;$&#123;crt&#125;" -keyfile "$&#123;cafile&#125;$&#123;key&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证证书</span></span><br><span class="line"><span class="function"><span class="title">verify_crt</span></span>()&#123;</span><br><span class="line">    input=<span class="variable">$&#123;1&#125;</span></span><br><span class="line">    cafile=<span class="variable">$&#123;2&#125;</span></span><br><span class="line">    openssl verify -CAfile <span class="string">"<span class="variable">$&#123;cafile&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;input&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将证书和私钥打包成p12格式</span></span><br><span class="line"><span class="function"><span class="title">export_p12</span></span>() &#123;</span><br><span class="line">    input=<span class="variable">$&#123;1&#125;</span></span><br><span class="line">    opassword=<span class="variable">$&#123;2&#125;</span></span><br><span class="line">    <span class="comment"># 是否输入了密码</span></span><br><span class="line">    password_param=<span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;#&#125;</span>"</span> -gt 2 ];<span class="keyword">then</span></span><br><span class="line">        password_param=<span class="string">"-passin pass:<span class="variable">$&#123;3&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    openssl pkcs12 <span class="variable">$&#123;password_param&#125;</span> -passout pass:<span class="variable">$&#123;opassword&#125;</span> \</span><br><span class="line">        -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;input&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span> \</span><br><span class="line">        -inkey <span class="string">"<span class="variable">$&#123;input&#125;</span><span class="variable">$&#123;key&#125;</span>"</span> -out <span class="string">"<span class="variable">$&#123;input&#125;</span><span class="variable">$&#123;p12&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于不同的ca有不同的会话环境，添加工具函数<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">create_conf</span></span>()&#123;</span><br><span class="line">    rdir=<span class="string">"<span class="variable">$&#123;1&#125;</span>"</span></span><br><span class="line">    <span class="comment"># 生成环境应该考虑相对路径，以及安全性的问题</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;rdir&#125;</span>"</span> == <span class="string">"/"</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rm -rf <span class="string">"<span class="variable">$&#123;rdir&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    mkdir -p <span class="string">"<span class="variable">$&#123;rdir&#125;</span>"</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$&#123;rdir&#125;</span>"</span></span><br><span class="line">    mkdir -p certs crl csr newcerts private</span><br><span class="line">    touch index.txt</span><br><span class="line">    <span class="built_in">echo</span> 1000 &gt; serial</span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局的密码，方便测试</span></span><br><span class="line">pass=123456</span><br><span class="line"><span class="comment"># ca chain，方便@1批量导入@2nginx需要</span></span><br><span class="line">cachain=<span class="string">"cachain"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建证书（含intermediate证书和业务证书）并签名</span></span><br><span class="line"><span class="function"><span class="title">create_and_sign</span></span>()&#123;</span><br><span class="line">	<span class="comment"># 输入文件，不含后缀</span></span><br><span class="line">    output=<span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="comment"># common name</span></span><br><span class="line">    cname=<span class="variable">$&#123;2&#125;</span></span><br><span class="line">    <span class="comment"># ca文件名称，不含后缀</span></span><br><span class="line">    caname=<span class="variable">$&#123;3&#125;</span></span><br><span class="line">    <span class="comment"># 创建证书私钥</span></span><br><span class="line">    create_key <span class="variable">$&#123;output&#125;</span> <span class="variable">$&#123;pass&#125;</span></span><br><span class="line">    <span class="comment"># 创建证书签名请求</span></span><br><span class="line">    create_csr <span class="variable">$&#123;cname&#125;</span> <span class="variable">$&#123;output&#125;</span> <span class="variable">$&#123;pass&#125;</span></span><br><span class="line">    <span class="comment"># 用指定的ca进行签名</span></span><br><span class="line">    ca_sign <span class="variable">$&#123;output&#125;</span> <span class="variable">$&#123;caname&#125;</span> <span class="variable">$&#123;pass&#125;</span></span><br><span class="line">    <span class="comment"># 打印信息</span></span><br><span class="line">    check_crt <span class="variable">$&#123;output&#125;</span></span><br><span class="line">    <span class="comment"># 校验</span></span><br><span class="line">    verify_crt <span class="variable">$&#123;output&#125;</span> <span class="variable">$&#123;cachain&#125;</span></span><br><span class="line">    <span class="comment"># 导出p12证书</span></span><br><span class="line">    export_p12 <span class="variable">$&#123;output&#125;</span> <span class="variable">$&#123;pass&#125;</span> <span class="variable">$&#123;pass&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$&#123;caname&#125;</span> = <span class="string">"ca"</span> ];<span class="keyword">then</span></span><br><span class="line">    	<span class="comment"># intermediate证书，需要更新cachain并且放置在最签名，rootca在最底部（注意顺序）</span></span><br><span class="line">        tmpfile=<span class="string">"/tmp/$<span class="variable">$_tmp_</span>$$"</span></span><br><span class="line">        cat <span class="string">"<span class="variable">$&#123;output&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span> | cat - <span class="string">"<span class="variable">$&#123;cachain&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span> &gt; <span class="string">"<span class="variable">$&#123;tmpfile&#125;</span>"</span> \</span><br><span class="line">            &amp;&amp; mv <span class="string">"<span class="variable">$&#123;tmpfile&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;cachain&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment"># 业务证书移除密码</span></span><br><span class="line">        remove_key_pwd <span class="string">"<span class="variable">$&#123;output&#125;</span>"</span> <span class="variable">$&#123;pass&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里创建一个root ca和intermediate ca</span></span><br><span class="line"><span class="comment"># init两个ca的环境，置于如何关联到这两个目录，在conf文件中配置</span></span><br><span class="line">create_conf ca</span><br><span class="line">create_conf imm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建root ca的私钥</span></span><br><span class="line">create_key ca <span class="variable">$&#123;pass&#125;</span></span><br><span class="line"><span class="comment"># 自签名</span></span><br><span class="line">self_sign root_ca ca <span class="variable">$&#123;pass&#125;</span></span><br><span class="line">check_crt ca</span><br><span class="line"><span class="comment"># 更新到cachain</span></span><br><span class="line">cat <span class="string">"ca<span class="variable">$&#123;crt&#125;</span>"</span> &gt; <span class="string">"<span class="variable">$&#123;cachain&#125;</span><span class="variable">$&#123;crt&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建intermediate ca 证书</span></span><br><span class="line">create_and_sign intermediate intermediate_ca ca</span><br><span class="line"><span class="comment"># 创建服务器证书，common name必须和域名匹配</span></span><br><span class="line">create_and_sign server <span class="string">"ycy.qiujinwu.com"</span> intermediate</span><br><span class="line"><span class="comment"># 创建客户证书，用于作客户端认证（双向认证）</span></span><br><span class="line">create_and_sign kingqiu <span class="string">"kingqiu"</span> intermediate</span><br></pre></td></tr></table></figure>
<h3 id="cnf配置"><a href="#cnf配置" class="headerlink" title="cnf配置"></a><a href="http://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/" target="_blank" rel="noopener">cnf配置</a></h3><p>上述的脚本有两个cnf文件，分别是ca_openssl.cnf和imm_openssl.cnf,原始文件在<a href="https://github.com/barretlee/autocreate-ca" target="_blank" rel="noopener">https://github.com/barretlee/autocreate-ca</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O ca_openssl.cnf \</span><br><span class="line">	https://raw.githubusercontent.com/barretlee/autocreate-ca/master/cnf/root-ca</span><br><span class="line">wget -O imm_openssl.cnf \</span><br><span class="line">	https://raw.githubusercontent.com/barretlee/autocreate-ca/master/cnf/intermediate-ca</span><br></pre></td></tr></table></figure></p>
<p>两者的区别<br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">king@king:/tmp/c$ diff *.cnf</span><br><span class="line">1,2c1,2</span><br><span class="line">&lt; # OpenSSL root CA configuration file.</span><br><span class="line">&lt; # Copy to `/root/ca/openssl.cnf`.</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; # OpenSSL intermediate CA configuration file.</span><br><span class="line">&gt; # Copy to `/root/ca/intermediate/openssl.cnf`.</span><br><span class="line">10c10</span><br><span class="line">&lt; dir               = /root/ca</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; dir               = /root/ca/intermediate</span><br><span class="line">19,20c19,20</span><br><span class="line">&lt; private_key       = $dir/private/ca.key.pem</span><br><span class="line">&lt; certificate       = $dir/certs/ca.cert.pem</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; private_key       = $dir/private/intermediate.key.pem</span><br><span class="line">&gt; certificate       = $dir/certs/intermediate.cert.pem</span><br><span class="line">24c24</span><br><span class="line">&lt; crl               = $dir/crl/ca.crl.pem</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; crl               = $dir/crl/intermediate.crl.pem</span><br><span class="line">35c35</span><br><span class="line">&lt; policy            = policy_strict</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; policy            = policy_loose</span><br></pre></td></tr></table></figure></p>
<p>这些配置和运行上述脚本的路径，以及文件名相关，我做了如下修改<br><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">king@king:/tmp/b$ diff ca_openssl.cnf imm_openssl.cnf </span><br><span class="line">1,2c1,2</span><br><span class="line">&lt; # OpenSSL root CA configuration file.</span><br><span class="line">&lt; # Copy to `/root/ca/openssl.cnf`.</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; # OpenSSL intermediate CA configuration file.</span><br><span class="line">&gt; # Copy to `/root/ca/intermediate/openssl.cnf`.</span><br><span class="line">10c10</span><br><span class="line">&lt; dir               = /tmp/b/ca</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; dir               = /tmp/b/imm</span><br><span class="line">19,20c19,20</span><br><span class="line">&lt; private_key       = $dir/../ca.key</span><br><span class="line">&lt; certificate       = $dir/../ca.crt</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; private_key       = $dir/../intermediate.key</span><br><span class="line">&gt; certificate       = $dir/../intermediate.crt</span><br><span class="line">24c24</span><br><span class="line">&lt; crl               = $dir/ca.crl.pem</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; crl               = $dir/intermediate.crl.pem</span><br><span class="line">35c35</span><br><span class="line">&lt; policy            = policy_strict</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; policy            = policy_loose</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>CA_default/dir的路径和证书的路径匹配</li>
<li>private_key、certificate和crl的路径正确</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[ CA_default ]</span></span><br><span class="line"><span class="comment"># Directory and file locations.</span></span><br><span class="line"><span class="attr">dir</span>               = /tmp/b/ca</span><br><span class="line"><span class="attr">certs</span>             = <span class="variable">$dir</span>/certs</span><br><span class="line"><span class="attr">crl_dir</span>           = <span class="variable">$dir</span>/crl</span><br><span class="line"><span class="attr">new_certs_dir</span>     = <span class="variable">$dir</span>/newcerts</span><br><span class="line"><span class="attr">database</span>          = <span class="variable">$dir</span>/index.txt</span><br><span class="line"><span class="attr">serial</span>            = <span class="variable">$dir</span>/serial</span><br><span class="line"><span class="attr">RANDFILE</span>          = <span class="variable">$dir</span>/.rand</span><br><span class="line"></span><br><span class="line"><span class="comment"># The root key and root certificate.</span></span><br><span class="line"><span class="attr">private_key</span>       = <span class="variable">$dir</span>/../ca.key</span><br><span class="line"><span class="attr">certificate</span>       = <span class="variable">$dir</span>/../ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># For certificate revocation lists.</span></span><br><span class="line"><span class="attr">crlnumber</span>         = <span class="variable">$dir</span>/crlnumber</span><br><span class="line"><span class="attr">crl</span>               = <span class="variable">$dir</span>/ca.crl.pem</span><br><span class="line"><span class="attr">crl_extensions</span>    = crl_ext</span><br><span class="line"><span class="attr">default_crl_days</span>  = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>运行之后，生成如下文件</p>
<blockquote>
<p>.<br>├── ca<br>│   ├── certs<br>│   ├── crl<br>│   ├── csr<br>│   ├── index.txt<br>│   ├── index.txt.attr<br>│   ├── index.txt.old<br>│   ├── newcerts<br>│   ├── private<br>│   ├── serial<br>│   └── serial.old<br>├── cachain.crt<br>├── ca.crt<br>├── ca.key<br>├── ca_openssl.cnf<br>├── imm<br>│   ├── certs<br>│   ├── crl<br>│   ├── csr<br>│   ├── index.txt<br>│   ├── index.txt.attr<br>│   ├── index.txt.attr.old<br>│   ├── index.txt.old<br>│   ├── newcerts<br>│   ├── private<br>│   ├── serial<br>│   └── serial.old<br>├── imm_openssl.cnf<br>├── intermediate.crt<br>├── intermediate.csr<br>├── intermediate.key<br>├── intermediate.p12<br>├── kingqiu.crt<br>├── kingqiu.csr<br>├── kingqiu.key<br>├── kingqiu.p12<br>├── server.crt<br>├── server.csr<br>├── server.key<br>└── server.p12</p>
</blockquote>
<h2 id="配置Nginx服务器证书"><a href="#配置Nginx服务器证书" class="headerlink" title="配置Nginx服务器证书"></a>配置Nginx服务器证书</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /tmp/b/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /tmp/b/server.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加Host之后即可访问<a href="https://ycy.qiujinwu.com/index.nginx-debian.html" target="_blank" rel="noopener">https://ycy.qiujinwu.com/index.nginx-debian.html</a>，由于是自建ca，浏览器是不信任的</p>
<h3 id="Linux下添加信任"><a href="#Linux下添加信任" class="headerlink" title="Linux下添加信任"></a>Linux下添加信任</h3><p>chrome和opera打开的界面都是一样的，并且数据互通。打开【证书管理器】之后，打开tab【授权中心】，选择【cachain.crt】，就一次性将root ca和intermediate ca一并导入了（必须都导入，否则无法通过信任，业务证书也无法看到完整的证书链），</p>
<h3 id="Windows下添加信任"><a href="#Windows下添加信任" class="headerlink" title="Windows下添加信任"></a>Windows下添加信任</h3><p>双击ca.crt和intermediate.crt依次安装到【受信任的根证书颁发机构】</p>
<p>再次刷新，即可看到锁变绿了，chrome有时需要关闭重新打开才能信任。</p>
<h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><p>注意nginx客户端的ca证书，<strong>使用的是cachain.crt证书链</strong><br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /tmp/b/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /tmp/b/server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_verify_client</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_verify_depth</span> <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_client_certificate</span> /tmp/b/cachain.crt;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-SSL-Client-Cert <span class="variable">$ssl_client_cert</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Linux下，打开【证书管理器】之后，打开tab【您的证书】，选择【kingqiu.p12】，输入密码，导入证书</p>
<p>Windows下，直接双击kingqiu.p12导入到默认的位置即可。</p>
<p>接下来再次访问就会弹出对话框选择证书，若无匹配的证书，就报错【400 Bad Request。No required SSL certificate was sent】</p>
<h2 id="典型的问题"><a href="#典型的问题" class="headerlink" title="典型的问题"></a>典型的问题</h2><p>Linux下chrome无法导入intermediate.crt，ca.crt无问题，换成opera正常。chrome提示【证书授权中心导入错误-无法解析文件】</p>
<p>提示O/S等不匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">The countryName field needed to be the same <span class="keyword">in</span> the</span><br><span class="line">CA certificate (NL) and the request (RO)</span><br></pre></td></tr></table></figure>
<p>king@king:/tmp/a$ sudo vi /etc/ssl/openssl.cnf<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For the CA policy</span></span><br><span class="line">[ policy_match ]</span><br><span class="line">countryName     = optional</span><br><span class="line">stateOrProvinceName = optional</span><br><span class="line">organizationName    = optional</span><br><span class="line"><span class="comment">#countryName        = match</span></span><br><span class="line"><span class="comment">#stateOrProvinceName    = match</span></span><br><span class="line"><span class="comment">#organizationName   = match</span></span><br><span class="line">organizationalUnitName  = optional</span><br><span class="line">commonName      = supplied</span><br><span class="line">emailAddress        = optional</span><br></pre></td></tr></table></figure></p>
<p>无法作为ca加入信任的授权中心</p>
<p>这通常是v3 extension的<strong>CA flag</strong>未启用或者不存在<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:/tmp/c$ openssl x509 -noout -text -<span class="keyword">in</span> intermediate.crt </span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 4096 (0x1000)</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=CN, ST=fasdf, OU=R&amp;D, CN=kingqiu</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jul 14 10:00:14 2017 GMT</span><br><span class="line">            Not After : May 23 10:00:14 2027 GMT</span><br><span class="line">        Subject: C=CN, ST=afdasf, OU=R&amp;D, CN=intermediate_ca</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:c0:81:d1:fb:2b:b8:0f:b6:8b:30:04:46:d0:78:</span><br><span class="line">                    28:8d</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Subject Key Identifier: </span><br><span class="line">                0D:6A:86:F1:62:AE:6A:74:05:12:31:09:BD:25:3B:B6:4E:98:BF:8E</span><br><span class="line">            X509v3 Authority Key Identifier: </span><br><span class="line">                keyid:E1:79:75:26:9D:C9:B4:FF:03:77:F9:5D:2F:BD:CB:C7:C6:DE:2A:20</span><br><span class="line"></span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">            	<span class="comment"># 注意这里</span></span><br><span class="line">                CA:TRUE, pathlen:0</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Digital Signature, Certificate Sign, CRL Sign</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         ce:79:c0:61:5c:39:66:f2:cf:30:34:ee:8b:7c:e1:f5:24:53:</span><br><span class="line">         1e:d7:cf:ed</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/14/ssl/" data-id="ckdbgbyy0005j43po4bsg6hh4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/14/ssl/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/签名/">签名</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/证书/">证书</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-rsa" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/14/rsa/">证书和签名学习汇总</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/14/rsa/" class="article-date"><time datetime="2017-07-14T11:36:59.000Z" itemprop="datePublished">2017-07-14</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/后端/">后端</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>证书相关的玩意，各种文件格式一大堆，大体可以分为：</p>
<ol>
<li>公私钥文件(.key …)</li>
<li>证书文件(.pem …)</li>
<li>证书签名申请文件(.csr …)</li>
</ol>
<p>具体的格式又分成两种</p>
<ol>
<li>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码</li>
<li>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.</li>
</ol>
<p>参考<a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">http://www.cnblogs.com/guogangj/p/4118605.html</a></p>
<blockquote>
<p>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p>
</blockquote>
<blockquote>
<p>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p>
</blockquote>
<p>关于DER格式，使用了偏门的编码<strong><a href="https://en.wikipedia.org/wiki/ASN.1" target="_blank" rel="noopener">ASN.1</a></strong>，参见<a href="https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem" target="_blank" rel="noopener">这里</a></p>
<h1 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h1><h2 id="key-pub"><a href="#key-pub" class="headerlink" title="key/pub"></a>key/pub</h2><p>公钥私钥文件<br>下面的代码生成私钥<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后面的数字可以成比率缩放</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure></p>
<p>实际上生成的key文件包含了公钥和私钥，下面的命令导出公钥<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> server.key -pubout &gt; server.pub</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:/tmp/a$ cat server.pub</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">king@king:/tmp/a$ cat server.key</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>前面提到，pem格式都是已BEGIN开头，那么中间又区分若干类型，关于公私钥，有</p>
<ol start="2">
<li>—–BEGIN RSA PUBLIC KEY—–  #PKCS#1</li>
<li>—–BEGIN RSA PRIVATE KEY—– #PKCS#1</li>
<li>—–BEGIN PUBLIC KEY—– #PKCS#8</li>
<li>—–BEGIN PRIVATE KEY—– #PKCS#8</li>
<li>—–BEGIN ENCRYPTED PRIVATE KEY—– #encrypted PKCS#8</li>
</ol>
<p>参见<a href="https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem" target="_blank" rel="noopener">这里</a>，具体而言，设计到PKCS#8 PKCS#1规范的差异</p>
<blockquote>
<p>BEGIN RSA PRIVATE KEY is PKCS#1 and is just an RSA key. It is essentially just the key object from PKCS#8, but without the version or algorithm identifier in front. BEGIN PRIVATE KEY is PKCS#8 and indicates that the key type is included in the key data itself. From the link:</p>
</blockquote>
<h2 id="PKCS-8-PKCS-1转换"><a href="#PKCS-8-PKCS-1转换" class="headerlink" title="PKCS#8 PKCS#1转换"></a>PKCS#8 PKCS#1转换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转pkcs8</span></span><br><span class="line">openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> server.key -outform pem -nocrypt -out server8.key</span><br><span class="line"><span class="comment"># 导出公钥</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> server8.key -pubout &gt; server8.pub</span><br><span class="line"><span class="comment"># 转pkcs1</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> server8.key -out server1.key</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:/tmp/a$ cat server8.key</span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">king@king:/tmp/a$ cat server8.pub</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">king@king:/tmp/a$ cat server1.key</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>参考<a href="http://www.voidcn.com/blog/duan19056/article/p-6137597.html" target="_blank" rel="noopener">这里</a></p>
<p>关于PKCS，参考</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A0%87%E5%87%86" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A0%87%E5%87%86</a></li>
<li><a href="http://falchion.iteye.com/blog/1472453" target="_blank" rel="noopener">http://falchion.iteye.com/blog/1472453</a></li>
</ol>
<h2 id="查看Key"><a href="#查看Key" class="headerlink" title="查看Key"></a>查看Key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> server8.key -text -noout</span><br><span class="line">openssl rsa -<span class="keyword">in</span> server1.key -text -noout</span><br><span class="line"><span class="comment"># Der格式</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> mykey.key -text -noout -inform der</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>pem 证书</li>
<li>crt certificate的三个字母 常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码</li>
<li>cer 还是certificate,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</li>
<li>csr ,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.</li>
<li>pfx/p12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码</li>
<li>jks 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS</li>
</ol>
<p>参考<a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">这里</a></p>
<h1 id="证书编码的转换"><a href="#证书编码的转换" class="headerlink" title="证书编码的转换"></a>证书编码的转换</h1><ol>
<li><p>PEM转为DER </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cert.crt -outform der -out cert.der</span><br></pre></td></tr></table></figure>
</li>
<li><p>DER转为PEM </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cert.crt -inform der -outform pem -out cert.pem</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>(提示:要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req…)</p>
</blockquote>
<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成服务器端的私钥</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="comment"># 生成服务器端证书</span></span><br><span class="line">openssl req -new -x509 -key server.key -out server.pem -days 3650</span><br></pre></td></tr></table></figure>
<h2 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -noout -text -<span class="keyword">in</span> server.pem</span><br></pre></td></tr></table></figure>
<h2 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h2><p>X.509 数字证书标准，定义证书文件的结构和内容，详情参考 <a href="https://www.ietf.org/rfc/rfc5280.txt" target="_blank" rel="noopener">RFC5280</a>,一般由用户公共密钥和用户标识符组成，此外还包括版本号、证书序列号、CA 标识符、签名算法标识、签发者名称、证书有效期等信息。</p>
<h2 id="Golang-TLS"><a href="#Golang-TLS" class="headerlink" title="Golang TLS"></a>Golang <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">TLS</a></h2><ol>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成”对话密钥”。</li>
<li>双方采用”对话密钥”进行加密通信。</li>
</ol>
<p>Golang基础库对tls支持非常好，Go Package tls部分实现了 tls 1.2的功能，可以满足我们日常的应用。Package crypto/x509提供了证书管理的相关操作。参考<a href="http://colobu.com/2016/06/07/simple-golang-tls-examples/" target="_blank" rel="noopener">http://colobu.com/2016/06/07/simple-golang-tls-examples/</a></p>
<p>server.go<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"crypto/tls"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"server.pem"</span>, <span class="string">"server.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	config := &amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125;</span><br><span class="line">	ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":4433"</span>, config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ln.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	r := bufio.NewReader(conn)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msg, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">println</span>(msg)</span><br><span class="line">		n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"world\n"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(n, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cli.go<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/tls"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conf := &amp;tls.Config&#123;</span><br><span class="line">		InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:4433"</span>, conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello\n"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(n, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">	n, err = conn.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(n, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>InsecureSkipVerify用来控制客户端是否证书和服务器主机名。如果设置为true,则不会校验证书以及证书中的主机名和服务器主机名是否一致。</p>
<h2 id="验证客户端身份"><a href="#验证客户端身份" class="headerlink" title="验证客户端身份"></a>验证客户端身份</h2><p>在有的情况下，需要双向认证，服务器也需要验证客户端的真实性。在这种情况下，我们需要服务器和客户端进行一点额外的配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"crypto/tls"</span></span><br><span class="line">	<span class="string">"crypto/x509"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"server.pem"</span>, <span class="string">"server.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	certBytes, err := ioutil.ReadFile(<span class="string">"client.pem"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"Unable to read cert.pem"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	clientCertPool := x509.NewCertPool()</span><br><span class="line">	ok := clientCertPool.AppendCertsFromPEM(certBytes)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"failed to parse root certificate"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	config := &amp;tls.Config&#123;</span><br><span class="line">		Certificates: []tls.Certificate&#123;cert&#125;,</span><br><span class="line">		ClientAuth:   tls.RequireAndVerifyClientCert,</span><br><span class="line">		ClientCAs:    clientCertPool,</span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ln.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := ln.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	r := bufio.NewReader(conn)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		msg, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">println</span>(msg)</span><br><span class="line">		n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"world\n"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(n, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.go<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/tls"</span></span><br><span class="line">	<span class="string">"crypto/x509"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"client.pem"</span>, <span class="string">"client.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	certBytes, err := ioutil.ReadFile(<span class="string">"client.pem"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"Unable to read cert.pem"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	clientCertPool := x509.NewCertPool()</span><br><span class="line">	ok := clientCertPool.AppendCertsFromPEM(certBytes)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"failed to parse root certificate"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	conf := &amp;tls.Config&#123;</span><br><span class="line">		RootCAs:            clientCertPool,</span><br><span class="line">		Certificates:       []tls.Certificate&#123;cert&#125;,</span><br><span class="line">		InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello\n"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(n, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">	n, err = conn.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(n, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>参考</p>
<ol>
<li><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="noopener">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></li>
<li><a href="http://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/" target="_blank" rel="noopener">http://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Public_key_certificate" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Public_key_certificate</a></li>
</ol>
<p>证书部分典型字段</p>
<ol>
<li>证书的发布机构</li>
<li>证书的有效期</li>
<li>公钥</li>
<li>证书所有者（Subject）</li>
<li>签名所使用的算法</li>
<li>指纹以及指纹算法</li>
</ol>
<p>◆Issuer (证书的发布机构)</p>
<p>指出是什么机构发布的这个证书，也就是指明这个证书是哪个公司创建的(只是创建证书，不是指证书的使用者)。例如”SecureTrust CA”</p>
<p>◆Valid from , Valid to (证书的有效期)</p>
<p>也就是证书的有效时间，或者说证书的使用期限。 过了有效期限，证书就会作废，不能使用了。</p>
<p>◆Public key (公钥)</p>
<p>这个我们在前面介绍公钥密码体制时介绍过，公钥是用来对消息进行加密的，第2章的例子中经常用到的。这个数字证书的公钥是2048位的，它的值可以在图的中间的那个对话框中看得到，是很长的一串数字。</p>
<p>◆Subject (主题)</p>
<p>这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 对于这里的证书来说，证书的所有者是Trustwave这个公司。</p>
<p>◆Signature algorithm (签名所使用的算法)</p>
<p>就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名(第1.5节中解释过数字签名)。</p>
<p>◆Thumbprint, Thumbprint algorithm (指纹以及指纹算法)</p>
<p>这个是用来保证证书的完整性的，也就是说确保证书没有被修改过，这东西的作用和2.7中说到的第3个问题类似。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。 注意，这个指纹会使用”SecureTrust CA”这个证书机构的私钥用签名算法(Signature algorithm)加密后和证书放在一起。</p>
<p>就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名(第1.5节中解释过数字签名)。</p>
<h2 id="如何向证书的发布机构去申请证书"><a href="#如何向证书的发布机构去申请证书" class="headerlink" title="如何向证书的发布机构去申请证书"></a>如何向证书的发布机构去申请证书</h2><p>举个例子方便大家理解，假设我们公司”ABC Company”花了1000块钱，向一个证书发布机构”SecureTrust CA”为我们自己的公司”ABC Company”申请了一张证书，注意，这个证书发布机构”SecureTrust CA”是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了”SecureTrust CA”的证书。”SecureTrust CA”在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个指纹算法计算出这些数字证书内容的一个指纹，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布。</p>
<h2 id="证书的吊销"><a href="#证书的吊销" class="headerlink" title="证书的吊销"></a>证书的吊销</h2><p>CA 证书的吊销存在两种机制，一种是在线检查，client 端向 CA 机构发送请求检查 server 公钥的靠谱性；第二种是 client 端储存一份 CA 提供的证书吊销列表，定期更新。前者要求查询服务器具备良好性能，后者要求每次更新提供下次更新的时间，一般时差在几天。安全性要求高的网站建议采用第一种方案。</p>
<p>大部分 CA 并不会提供吊销机制（CRL/OCSP），靠谱的方案是为根证书提供中间证书，一旦中间证书的私钥泄漏或者证书过期，可以直接吊销中间证书并给用户颁发新的证书。中间证书的签证原理于上上条提到的原理一样，中间证书还可以产生下一级中间证书，多级证书可以减少根证书的管理负担。</p>
<h2 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a><a href="http://www.jianshu.com/p/46e48bc517d0" target="_blank" rel="noopener">证书链</a></h2><p>除了end-user之外，证书被分为root Certificates和intermediates Certificates。相应地，CA也分了两种类型：root CAs 和 intermediates CAs。首先，CA的组织结构是一个树结构，一个root CAs下面包含多个intermediates CAs，而intermediates又可以包含多个intermediates CAs。root CAs 和 intermediates CAs都可以颁发证书给用户，颁发的证书分别是root Certificates和intermediates Certificates，最终用户用来认证公钥的证书则被称为end-user Certificates。</p>
<p>我们使用end-user certificates来确保加密传输数据的公钥(public key)不被篡改，而又如何确保end-user certificates的合法性呢？这个认证过程跟公钥的认证过程类似，首先获取颁布end-user certificates的CA的证书，然后验证end-user certificates的signature。一般来说，root CAs不会直接颁布end-user certificates的，而是授权给多个二级CA，而二级CA又可以授权给多个三级CA，这些中间的CA就是intermediates CAs，它们才会颁布end-user certificates。</p>
<p>但是intermediates certificates的可靠性又如何保证呢？这就是涉及到证书链，Certificate Chain ，链式向上验证证书，直到Root Certificates</p>
<p>那Root Certificates又是如何来的呢？根据 <a href="https://support.dnsimple.com/articles/what-is-ssl-certificate-chain/" target="_blank" rel="noopener">https://support.dnsimple.com/articles/what-is-ssl-certificate-chain/</a> 这篇文章的说法，除了可以下载安装之外，device（例如浏览器，操作系统）都会内置一些root certificates，称之为trusted root certificates，<a href="https://support.apple.com/en-us/HT202858" target="_blank" rel="noopener">https://support.apple.com/en-us/HT202858</a> ，在Apple的官网上可以看到这个列表，有各个操作版本直接内置的Root Certificates。</p>
<p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA为什么不直接版本证书，而是要搞那么多中间层级呢？找了一下，godaddy官方给了一个答案，为了确保root certificates的绝对安全性，<a href="https://sg.godaddy.com/en/help/what-is-an-intermediate-certificate-868" target="_blank" rel="noopener">https://sg.godaddy.com/en/help/what-is-an-intermediate-certificate-868</a> ，将根证书隔离地越严格越好。</p>
<h2 id="证书请求-certificate-sign-request"><a href="#证书请求-certificate-sign-request" class="headerlink" title="证书请求(certificate sign request)"></a>证书请求(certificate sign request)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ssl.key 2048</span><br><span class="line">openssl req -new -key ssl.key -out ssl.csr</span><br></pre></td></tr></table></figure>
<p>证书(certificate)和证书请求(certificate sign request)</p>
<ol>
<li>证书是自签名或CA签名过的凭据，用来进行身份认证</li>
<li>证书请求是对签名的请求，需要使用私钥进行签名</li>
</ol>
<p>x509命令可以将证书和证书请求相互转换</p>
<h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>自签名的原理是用私钥对该私钥生成的证书请求进行签名，生成证书文件。该证书的签发者就是自己，所以验证方必须有该证书的私钥才能对签发信息进行验证，所以要么验证方信任一切证书，面临冒名顶替的风险，要么被验证方的私钥（或加密过的私钥）需要发送到验证方手中，面临私钥泄露的风险。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:/tmp/a$ openssl rsa -<span class="keyword">in</span> ssl.key -des3 -out encrypted.key</span><br><span class="line">king@king:/tmp/a$ openssl req -new -key ssl.key -out ssl.csr</span><br><span class="line">king@king:/tmp/a$ openssl x509 -req -<span class="keyword">in</span> ssl.csr -signkey ssl.key -out ssl.crt</span><br></pre></td></tr></table></figure></p>
<h1 id="Exe签名"><a href="#Exe签名" class="headerlink" title="Exe签名"></a>Exe签名</h1><p>导出p12格式的证书，易被Windows下的工具支持<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> ssl.crt -inkey ssl.key -out ssl.p12</span><br><span class="line"><span class="comment"># 用Windows sdk的工具signtool实现exe文件签名</span></span><br><span class="line">signtool sign /f ssl.pfx /p mypassword abc.exe</span><br></pre></td></tr></table></figure></p>
<h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><ol>
<li>服务器把证书信息发送给浏览器</li>
<li>浏览器现在开始验证证书的合法性，证书验证之后，随机一个对称加密的秘钥，并加密一段握手信息，并用公钥加密秘钥之后发给服务器</li>
<li>服务器用私钥解密之后得到秘钥，解密密文验证无误后，加密一段握手信息发送给浏览器</li>
<li>浏览器验证密文无误，开始SSL安全连接</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>直接用rsa加密，效率太低</li>
<li>直接用rsa加密，回程无安全性</li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/14/rsa/" data-id="ckdbgbyxk004x43pob96c2k04" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/14/rsa/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/签名/">签名</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/证书/">证书</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-ketama" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/06/ketama/">ketama算法Golang实现</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/06/ketama/" class="article-date"><time datetime="2017-07-06T04:54:28.000Z" itemprop="datePublished">2017-07-06</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码学习/">源码学习</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>源码 <a href="https://github.com/serialx/hashring" target="_blank" rel="noopener">https://github.com/serialx/hashring</a></p>
<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HashKey <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序支持</span></span><br><span class="line"><span class="keyword">type</span> HashKeyOrder []HashKey</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HashKeyOrder)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HashKeyOrder)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h HashKeyOrder)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashRing <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 一致性hash 虚拟node，以及关联的节点</span></span><br><span class="line">    ring       <span class="keyword">map</span>[HashKey]<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 所有的虚拟node，（重新）生成之后，会排序，以便快速二分查找</span></span><br><span class="line">    <span class="comment">// 通过二分查找，找到比查询key小的最大key，然后查找ring</span></span><br><span class="line">    sortedKeys []HashKey</span><br><span class="line">    <span class="comment">// 原始数据，所有的节点</span></span><br><span class="line">    nodes      []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 原始数据，所有的节点权重</span></span><br><span class="line">    weights    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(nodes []<span class="keyword">string</span>)</span> *<span class="title">HashRing</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个对象</span></span><br><span class="line">    hashRing := &amp;HashRing&#123;</span><br><span class="line">        ring:       <span class="built_in">make</span>(<span class="keyword">map</span>[HashKey]<span class="keyword">string</span>),</span><br><span class="line">        sortedKeys: <span class="built_in">make</span>([]HashKey, <span class="number">0</span>),</span><br><span class="line">        nodes:      nodes,</span><br><span class="line">        weights:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成虚拟node</span></span><br><span class="line">    hashRing.generateCircle()</span><br><span class="line">    <span class="keyword">return</span> hashRing</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和上个函数比，增加权重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWithWeights</span><span class="params">(weights <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> *<span class="title">HashRing</span></span> &#123;</span><br><span class="line">    nodes := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(weights))</span><br><span class="line">    <span class="keyword">for</span> node, _ := <span class="keyword">range</span> weights &#123;</span><br><span class="line">        nodes = <span class="built_in">append</span>(nodes, node)</span><br><span class="line">    &#125;</span><br><span class="line">    hashRing := &amp;HashRing&#123;</span><br><span class="line">        ring:       <span class="built_in">make</span>(<span class="keyword">map</span>[HashKey]<span class="keyword">string</span>),</span><br><span class="line">        sortedKeys: <span class="built_in">make</span>([]HashKey, <span class="number">0</span>),</span><br><span class="line">        nodes:      nodes,</span><br><span class="line">        weights:    weights,</span><br><span class="line">    &#125;</span><br><span class="line">    hashRing.generateCircle()</span><br><span class="line">    <span class="keyword">return</span> hashRing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成虚拟node"><a href="#生成虚拟node" class="headerlink" title="生成虚拟node"></a>生成虚拟node</h2><p>核心逻辑<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashRing)</span> <span class="title">generateCircle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取总的权重</span></span><br><span class="line">    totalWeight := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> h.nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> weight, ok := h.weights[node]; ok &#123;</span><br><span class="line">            totalWeight += weight</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalWeight += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次对每个节点生成若干虚拟node</span></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> h.nodes &#123;</span><br><span class="line">        weight := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否指定了权重</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := h.weights[node]; ok &#123;</span><br><span class="line">            weight = h.weights[node]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置虚拟node的数量，40这个乘数因子可调整</span></span><br><span class="line">        <span class="comment">// 数量越大，分布越均匀，但是性能相对较低</span></span><br><span class="line">        factor := math.Floor(<span class="keyword">float64</span>(<span class="number">40</span>*<span class="built_in">len</span>(h.nodes)*weight) / <span class="keyword">float64</span>(totalWeight))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次生成虚拟node（里面还会细分成多个，实现细节问题）</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="keyword">int</span>(factor); j++ &#123;</span><br><span class="line">            <span class="comment">// 生成一个key（受factor影响）</span></span><br><span class="line">            nodeKey := fmt.Sprintf(<span class="string">"%s-%d"</span>, node, j)</span><br><span class="line">            <span class="comment">// 生成MD5（16大小的[]byte)</span></span><br><span class="line">            bKey := hashDigest(nodeKey)</span><br><span class="line">            <span class="comment">// 原代码只计算了前面12Byte，可以用完16byte，生成4个虚拟node</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">                <span class="comment">// 生成一个虚拟node的key</span></span><br><span class="line">                key := hashVal(bKey[i*<span class="number">4</span> : i*<span class="number">4</span>+<span class="number">4</span>])</span><br><span class="line">                <span class="comment">// 关联后端的节点</span></span><br><span class="line">                h.ring[key] = node</span><br><span class="line">                <span class="comment">// 插入到查找的slice</span></span><br><span class="line">                h.sortedKeys = <span class="built_in">append</span>(h.sortedKeys, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序，方便二分查找</span></span><br><span class="line">    sort.Sort(HashKeyOrder(h.sortedKeys))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashRing)</span> <span class="title">GetNode</span><span class="params">(stringKey <span class="keyword">string</span>)</span> <span class="params">(node <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 查找key所在的虚拟node</span></span><br><span class="line">    pos, ok := h.GetNodePos(stringKey)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回后端节点</span></span><br><span class="line">    <span class="keyword">return</span> h.ring[h.sortedKeys[pos]], <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashRing)</span> <span class="title">GenKey</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">HashKey</span></span> &#123;</span><br><span class="line">    <span class="comment">// 查询后端节点时，给key生成hash</span></span><br><span class="line">    bKey := hashDigest(key)</span><br><span class="line">    <span class="comment">//MD5取前四位，比较简单</span></span><br><span class="line">    <span class="keyword">return</span> hashVal(bKey[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashRing)</span> <span class="title">GetNodePos</span><span class="params">(stringKey <span class="keyword">string</span>)</span> <span class="params">(pos <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 无数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(h.ring) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    key := h.GenKey(stringKey)</span><br><span class="line"></span><br><span class="line">    nodes := h.sortedKeys</span><br><span class="line">    <span class="comment">// 二分查找key</span></span><br><span class="line">    pos = sort.Search(<span class="built_in">len</span>(nodes), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> nodes[i] &gt; key &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到就第一个</span></span><br><span class="line">    <span class="keyword">if</span> pos == <span class="built_in">len</span>(nodes) &#123;</span><br><span class="line">        <span class="comment">// Wrap the search, should return first node</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则返回找到的node</span></span><br><span class="line">        <span class="keyword">return</span> pos, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>为了保证数据可靠性，可以将每份数据都写入多个后端节点，一个小问题是</p>
<ol>
<li><strong>不同的key所在的后端节点有交叉</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// size表示返回的副本数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashRing)</span> <span class="title">GetNodes</span><span class="params">(stringKey <span class="keyword">string</span>, size <span class="keyword">int</span>)</span> <span class="params">(nodes []<span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获得key所在的虚拟node</span></span><br><span class="line">    pos, ok := h.GetNodePos(stringKey)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没那么多节点</span></span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="built_in">len</span>(h.nodes) &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于节点关联的虚拟node交叉放置，下面的map用于判断是否已经get了这个节点</span></span><br><span class="line">    returnedValues := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, size)</span><br><span class="line">    <span class="comment">//mergedSortedKeys := append(h.sortedKeys[pos:], h.sortedKeys[:pos]...)</span></span><br><span class="line">    <span class="comment">// 已经get的节点</span></span><br><span class="line">    resultSlice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从key所在的虚拟node开始查找，到尾自动从第一个开始</span></span><br><span class="line">    <span class="keyword">for</span> i := pos; i &lt; pos+<span class="built_in">len</span>(h.sortedKeys); i++ &#123;</span><br><span class="line">        key := h.sortedKeys[i%<span class="built_in">len</span>(h.sortedKeys)]</span><br><span class="line">        <span class="comment">// 检查这个后端节点是否已经保存</span></span><br><span class="line">        val := h.ring[key]</span><br><span class="line">        <span class="keyword">if</span> !returnedValues[val] &#123;</span><br><span class="line">            <span class="comment">// 没有就保存起来，并且标记已保存</span></span><br><span class="line">            returnedValues[val] = <span class="literal">true</span></span><br><span class="line">            resultSlice = <span class="built_in">append</span>(resultSlice, val)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(returnedValues) == size &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultSlice, <span class="built_in">len</span>(resultSlice) == size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增删改节点"><a href="#增删改节点" class="headerlink" title="增删改节点"></a>增删改节点</h2><p>目前的实现都是先更新原始数据，然后重新生成虚拟node，个人认为优化的地方</p>
<ol>
<li><strong>由于每次新增一个都需要重新生成，若要更新多个会比较慢，可以增加批量接口</strong></li>
<li><strong>重新生成时，不知道变更的数据，若需要数据迁移，需要额外处理</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func (h *HashRing) AddNode(node string) *HashRing &#123;</span><br><span class="line">    <span class="built_in">return</span> h.AddWeightedNode(node, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HashRing) AddWeightedNode(node string, weight int) *HashRing &#123;</span><br><span class="line">    <span class="keyword">if</span> weight &lt;= 0 &#123;</span><br><span class="line">        <span class="built_in">return</span> h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存在就不处理</span><br><span class="line">    <span class="keyword">for</span> _, eNode := range h.nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> eNode == node &#123;</span><br><span class="line">            <span class="built_in">return</span> h</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加入到原始数据</span><br><span class="line">    nodes := make([]string, len(h.nodes), len(h.nodes)+1)</span><br><span class="line">    copy(nodes, h.nodes)</span><br><span class="line">    nodes = append(nodes, node)</span><br><span class="line"></span><br><span class="line">    weights := make(map[string]int)</span><br><span class="line">    <span class="keyword">for</span> eNode, eWeight := range h.weights &#123;</span><br><span class="line">        weights[eNode] = eWeight</span><br><span class="line">    &#125;</span><br><span class="line">    weights[node] = weight</span><br><span class="line"></span><br><span class="line">    hashRing := &amp;HashRing&#123;</span><br><span class="line">        ring:       make(map[HashKey]string),</span><br><span class="line">        sortedKeys: make([]HashKey, 0),</span><br><span class="line">        nodes:      nodes,</span><br><span class="line">        weights:    weights,</span><br><span class="line">    &#125;</span><br><span class="line">    // 重新生成</span><br><span class="line">    hashRing.generateCircle()</span><br><span class="line">    <span class="built_in">return</span> hashRing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/06/ketama/" data-id="ckdbgbywu003943porn6x9t4e" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/06/ketama/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/一致性hash/">一致性hash</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-ngrok" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/ngrok/">Ngrok客户端源码学习笔记</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/05/ngrok/" class="article-date"><time datetime="2017-07-05T14:29:10.000Z" itemprop="datePublished">2017-07-05</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码学习/">源码学习</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>关于ngrok的使用，参考<a href="http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/" target="_blank" rel="noopener">http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/</a></p>
<p>源码地址 <a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a>，我fork一份在<a href="https://github.com/qjw/ngrok" target="_blank" rel="noopener">https://github.com/qjw/ngrok</a>,代码相对路径<strong>src/github.com/qjw/ngrok/src/ngrok/server/</strong>。</p>
<p>main入口在<strong>src/github.com/qjw/ngrok/src/ngrok/main</strong>,分成客户端和服务端/ngrokd/ngrokd.go、/ngrok/ngrok.go。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cli.go <span class="comment">#命令行相关</span></span><br><span class="line">├── config.go <span class="comment">#配置相关</span></span><br><span class="line">├── controller.go <span class="comment"># 控制器，用于管理view/网络/config/state等</span></span><br><span class="line">├── main.go <span class="comment">#入口</span></span><br><span class="line">├── metrics.go <span class="comment">#统计数据</span></span><br><span class="line">├── model.go <span class="comment"># 核心逻辑</span></span><br><span class="line">├── mvc</span><br><span class="line">│   ├── controller.go <span class="comment"># controller interface</span></span><br><span class="line">│   ├── model.go <span class="comment"># interface</span></span><br><span class="line">│   ├── state.go <span class="comment"># interface和状态定义</span></span><br><span class="line">│   └── view.go <span class="comment"># interface</span></span><br><span class="line">├── tls.go <span class="comment">#tls加密</span></span><br><span class="line">└── views  <span class="comment">#view</span></span><br><span class="line">    ├── term <span class="comment">#终端view</span></span><br><span class="line">    │   ├── area.go</span><br><span class="line">    │   ├── http.go</span><br><span class="line">    │   └── view.go</span><br><span class="line">    └── web <span class="comment">#web view</span></span><br><span class="line">        ├── http.go</span><br><span class="line">        └── view.go</span><br></pre></td></tr></table></figure>
<h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NewController().Run(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">()</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">    ctl := &amp;Controller&#123;</span><br><span class="line">        Logger:  log.NewPrefixLogger(<span class="string">"controller"</span>),</span><br><span class="line">        updates: util.NewBroadcast(),</span><br><span class="line">        cmds:    <span class="built_in">make</span>(<span class="keyword">chan</span> command),</span><br><span class="line">        views:   <span class="built_in">make</span>([]mvc.View, <span class="number">0</span>),</span><br><span class="line">        state:   <span class="built_in">make</span>(<span class="keyword">chan</span> mvc.State),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行启动逻辑<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctl *Controller)</span> <span class="title">Run</span><span class="params">(config *Configuration)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Save the configuration</span></span><br><span class="line">    ctl.config = config</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> model *ClientModel</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建model（核心逻辑所在）</span></span><br><span class="line">    <span class="keyword">if</span> ctl.model == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在就创建</span></span><br><span class="line">        model = ctl.SetupModel(config)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model = ctl.model.(*ClientModel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init the model</span></span><br><span class="line">    <span class="keyword">var</span> state mvc.State = model</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化web view</span></span><br><span class="line">    <span class="keyword">var</span> webView *web.WebView</span><br><span class="line">    <span class="keyword">if</span> config.InspectAddr != <span class="string">"disabled"</span> &#123;</span><br><span class="line">        webView = web.NewWebView(ctl, config.InspectAddr)</span><br><span class="line">        ctl.AddView(webView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化term view</span></span><br><span class="line">    <span class="keyword">var</span> termView *term.TermView</span><br><span class="line">    <span class="keyword">if</span> config.LogTo != <span class="string">"stdout"</span> &#123;</span><br><span class="line">        termView = term.NewTermView(ctl)</span><br><span class="line">        ctl.AddView(termView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将view关联到controller</span></span><br><span class="line">    <span class="keyword">for</span> _, protocol := <span class="keyword">range</span> model.GetProtocols() &#123;</span><br><span class="line">        <span class="keyword">switch</span> p := protocol.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *proto.Http:</span><br><span class="line">            <span class="keyword">if</span> termView != <span class="literal">nil</span> &#123;</span><br><span class="line">                ctl.AddView(termView.NewHttpView(p))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> webView != <span class="literal">nil</span> &#123;</span><br><span class="line">                ctl.AddView(webView.NewHttpView(p))</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心逻辑入口</span></span><br><span class="line">    ctl.Go(ctl.model.Run)</span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> obj := &lt;-ctl.cmds:</span><br><span class="line">            <span class="comment">// 关闭command</span></span><br><span class="line">            <span class="keyword">switch</span> cmd := obj.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> cmdQuit:</span><br><span class="line">                msg := cmd.message</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 等待退出</span></span><br><span class="line">                    ctl.doShutdown()</span><br><span class="line">                    fmt.Println(msg)</span><br><span class="line">                    done &lt;- <span class="number">1</span></span><br><span class="line">                &#125;()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回放命令</span></span><br><span class="line">            <span class="keyword">case</span> cmdPlayRequest:</span><br><span class="line">                ctl.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ctl.model.PlayRequest(cmd.tunnel, cmd.payload) &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新state</span></span><br><span class="line">        <span class="keyword">case</span> obj := &lt;-updates:</span><br><span class="line">            state = obj.(mvc.State)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ctl.state &lt;- state:</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终进入一个死循环，似乎作者并没有打算让它和谐地退出<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// how long we should wait before we reconnect</span></span><br><span class="line">    maxWait := <span class="number">30</span> * time.Second</span><br><span class="line">    wait := <span class="number">1</span> * time.Second</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 开始发起连接请求，响应报文等</span></span><br><span class="line">        <span class="comment">// 注意是阻塞的，若该函数返回了，说明掉线了</span></span><br><span class="line">        c.control()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败后，第一次状态未变，此时重置wait的时间间隔</span></span><br><span class="line">        <span class="keyword">if</span> c.connStatus == mvc.ConnOnline &#123;</span><br><span class="line">            wait = <span class="number">1</span> * time.Second</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep，避免无畏的不停请求，浪费服务器资源</span></span><br><span class="line">        time.Sleep(wait)</span><br><span class="line">        <span class="comment">// 失败了继续加大重试的间隔</span></span><br><span class="line">        wait = <span class="number">2</span> * wait</span><br><span class="line">        wait = time.Duration(math.Min(<span class="keyword">float64</span>(wait), <span class="keyword">float64</span>(maxWait)))</span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line">        c.connStatus = mvc.ConnReconnecting</span><br><span class="line">        <span class="comment">// 刷新各种view</span></span><br><span class="line">        c.update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctl *Controller)</span> <span class="title">doShutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctl.Info(<span class="string">"Shutting down"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for all of the views, plus the model</span></span><br><span class="line">    wg.Add(<span class="built_in">len</span>(ctl.views) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有的view</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> ctl.views &#123;</span><br><span class="line">        vClosure := v</span><br><span class="line">        ctl.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            vClosure.Shutdown()</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭model（核心逻辑）</span></span><br><span class="line">    ctl.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctl.model.Shutdown()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用WaitGroup等待多个goruntune</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">control</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// establish control channel</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        ctlConn conn.Conn</span><br><span class="line">        err     error</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起连接</span></span><br><span class="line">    <span class="keyword">if</span> c.proxyUrl == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="comment">// simple non-proxied case, just connect to the server</span></span><br><span class="line">        ctlConn, err = conn.Dial(c.serverAddr, <span class="string">"ctl"</span>, c.tlsConfig)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctlConn, err = conn.DialHttpProxy(c.proxyUrl, c.serverAddr, <span class="string">"ctl"</span>, c.tlsConfig)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// authenticate with the server</span></span><br><span class="line">    auth := &amp;msg.Auth&#123;</span><br><span class="line">        ClientId:  c.id,</span><br><span class="line">        OS:        runtime.GOOS,</span><br><span class="line">        Arch:      runtime.GOARCH,</span><br><span class="line">        Version:   version.Proto,</span><br><span class="line">        MmVersion: version.MajorMinor(),</span><br><span class="line">        User:      c.authToken,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送连接报文</span></span><br><span class="line">    <span class="keyword">if</span> err = msg.WriteMsg(ctlConn, auth); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待响应</span></span><br><span class="line">    <span class="keyword">var</span> authResp msg.AuthResp</span><br><span class="line">    <span class="keyword">if</span> err = msg.ReadMsgInto(ctlConn, &amp;authResp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> authResp.Error != <span class="string">""</span> &#123;</span><br><span class="line">        emsg := fmt.Sprintf(<span class="string">"Failed to authenticate to server: %s"</span>, authResp.Error)</span><br><span class="line">        c.ctl.Shutdown(emsg)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.id = authResp.ClientId</span><br><span class="line">    c.serverVersion = authResp.MmVersion</span><br><span class="line">    c.Info(<span class="string">"Authenticated with server, client id: %v"</span>, c.id)</span><br><span class="line">    <span class="comment">// 更新view</span></span><br><span class="line">    c.update()</span><br><span class="line">    <span class="comment">// 更新配置</span></span><br><span class="line">    <span class="keyword">if</span> err = SaveAuthToken(c.configPath, c.authToken); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.Error(<span class="string">"Failed to save auth token: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// request tunnels</span></span><br><span class="line">    reqIdToTunnelConfig := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*TunnelConfiguration)</span><br><span class="line">    <span class="keyword">for</span> _, config := <span class="keyword">range</span> c.tunnelConfig &#123;</span><br><span class="line">        <span class="comment">// create the protocol list to ask for</span></span><br><span class="line">        <span class="keyword">var</span> protocols []<span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> proto, _ := <span class="keyword">range</span> config.Protocols &#123;</span><br><span class="line">            protocols = <span class="built_in">append</span>(protocols, proto)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册tunnel</span></span><br><span class="line">        reqTunnel := &amp;msg.ReqTunnel&#123;</span><br><span class="line">            ReqId:      util.RandId(<span class="number">8</span>),</span><br><span class="line">            Protocol:   strings.Join(protocols, <span class="string">"+"</span>),</span><br><span class="line">            Hostname:   config.Hostname,</span><br><span class="line">            Subdomain:  config.Subdomain,</span><br><span class="line">            HttpAuth:   config.HttpAuth,</span><br><span class="line">            RemotePort: config.RemotePort,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        <span class="keyword">if</span> err = msg.WriteMsg(ctlConn, reqTunnel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储这些配置，后面新建tunnel需要</span></span><br><span class="line">        reqIdToTunnelConfig[reqTunnel.ReqId] = config</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始心跳</span></span><br><span class="line">    lastPong := time.Now().UnixNano()</span><br><span class="line">    c.ctl.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.heartbeat(&amp;lastPong, ctlConn) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main control loop</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rawMsg msg.Message</span><br><span class="line">        <span class="keyword">if</span> rawMsg, err = msg.ReadMsg(ctlConn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *msg.ReqProxy:</span><br><span class="line">            <span class="comment">// 收到proxy请求，就向服务器发起一个proxy请求</span></span><br><span class="line">            c.ctl.Go(c.proxy)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> *msg.Pong:</span><br><span class="line">            <span class="comment">// 更新心跳</span></span><br><span class="line">            atomic.StoreInt64(&amp;lastPong, time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> *msg.NewTunnel:</span><br><span class="line">            <span class="comment">// 注册tunnel确认</span></span><br><span class="line">            <span class="keyword">if</span> m.Error != <span class="string">""</span> &#123;</span><br><span class="line">                emsg := fmt.Sprintf(<span class="string">"Server failed to allocate tunnel: %s"</span>, m.Error)</span><br><span class="line">                c.Error(emsg)</span><br><span class="line">                c.ctl.Shutdown(emsg)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tunnel := mvc.Tunnel&#123;</span><br><span class="line">                PublicUrl: m.Url,</span><br><span class="line">                LocalAddr: reqIdToTunnelConfig[m.ReqId].Protocols[m.Protocol],</span><br><span class="line">                Protocol:  c.protoMap[m.Protocol],</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存tunnel对象，用于view的数据呈现</span></span><br><span class="line">            <span class="comment">// 另外是申请proxy时，作校验</span></span><br><span class="line">            c.tunnels[tunnel.PublicUrl] = tunnel</span><br><span class="line">            <span class="comment">// 更新状态</span></span><br><span class="line">            c.connStatus = mvc.ConnOnline</span><br><span class="line">            <span class="comment">// 同步到view</span></span><br><span class="line">            c.update()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ctlConn.Warn(<span class="string">"Ignoring unknown control message %v "</span>, m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">heartbeat</span><span class="params">(lastPongAddr *<span class="keyword">int64</span>, conn conn.Conn)</span></span> &#123;</span><br><span class="line">    lastPing := time.Unix(atomic.LoadInt64(lastPongAddr)<span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    ping := time.NewTicker(pingInterval)</span><br><span class="line">    pongCheck := time.NewTicker(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否过期</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-pongCheck.C:</span><br><span class="line">            lastPong := time.Unix(<span class="number">0</span>, atomic.LoadInt64(lastPongAddr))</span><br><span class="line">            needPong := lastPong.Sub(lastPing) &lt; <span class="number">0</span></span><br><span class="line">            pongLatency := time.Since(lastPing)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> needPong &amp;&amp; pongLatency &gt; maxPongLatency &#123;</span><br><span class="line">                c.Info(<span class="string">"Last ping: %v, Last pong: %v"</span>, lastPing, lastPong)</span><br><span class="line">                c.Info(<span class="string">"Connection stale, haven't gotten PongMsg in %d seconds"</span>, <span class="keyword">int</span>(pongLatency.Seconds()))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期发送心跳</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ping.C:</span><br><span class="line">            err := msg.WriteMsg(conn, &amp;msg.Ping&#123;&#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                conn.Debug(<span class="string">"Got error %v when writing PingMsg"</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastPing = time.Now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>当收到一个proxy请求时，会新开一个goruntune来处理<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">proxy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        remoteConn conn.Conn</span><br><span class="line">        err        error</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> c.proxyUrl == <span class="string">""</span> &#123;</span><br><span class="line">        remoteConn, err = conn.Dial(c.serverAddr, <span class="string">"pxy"</span>, c.tlsConfig)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        remoteConn, err = conn.DialHttpProxy(c.proxyUrl, c.serverAddr, <span class="string">"pxy"</span>, c.tlsConfig)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> remoteConn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应报文</span></span><br><span class="line">    err = msg.WriteMsg(remoteConn, &amp;msg.RegProxy&#123;ClientId: c.id&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        remoteConn.Error(<span class="string">"Failed to write RegProxy: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待具体的业务报文，</span></span><br><span class="line">    <span class="comment">// 之所以需要这么个报文，是因为需要这个报文中的内容来定位tunnel，进而获取本地端的参数</span></span><br><span class="line">    <span class="comment">// 因为客户端也是一个数据中转，它一样有下游节点</span></span><br><span class="line">    <span class="keyword">var</span> startPxy msg.StartProxy</span><br><span class="line">    <span class="keyword">if</span> err = msg.ReadMsgInto(remoteConn, &amp;startPxy); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        remoteConn.Error(<span class="string">"Server failed to write StartProxy: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到tunnel</span></span><br><span class="line">    tunnel, ok := c.tunnels[startPxy.Url]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        remoteConn.Error(<span class="string">"Couldn't find tunnel for proxy: %s"</span>, startPxy.Url)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接本地端</span></span><br><span class="line">    start := time.Now()</span><br><span class="line">    localConn, err := conn.Dial(tunnel.LocalAddr, <span class="string">"prv"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        remoteConn.Warn(<span class="string">"Failed to open private leg %s: %v"</span>, tunnel.LocalAddr, err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tunnel.Protocol.GetName() == <span class="string">"http"</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> localConn.Close()</span><br><span class="line"></span><br><span class="line">    m := c.metrics</span><br><span class="line">    m.proxySetupTimer.Update(time.Since(start))</span><br><span class="line">    m.connMeter.Mark(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 更新view</span></span><br><span class="line">    c.update()</span><br><span class="line">    m.connTimer.Time(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        localConn := tunnel.Protocol.WrapConn(localConn,  \</span><br><span class="line">            mvc.ConnectionContext&#123;Tunnel: tunnel, ClientAddr: startPxy.ClientAddr&#125;)</span><br><span class="line">        <span class="comment">// 数据交换</span></span><br><span class="line">        bytesIn, bytesOut := conn.Join(localConn, remoteConn)</span><br><span class="line">        m.bytesIn.Update(bytesIn)</span><br><span class="line">        m.bytesOut.Update(bytesOut)</span><br><span class="line">        m.bytesInCount.Inc(bytesIn)</span><br><span class="line">        m.bytesOutCount.Inc(bytesOut)</span><br><span class="line">    &#125;)</span><br><span class="line">    c.update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个典型的proxy开始报文如下<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"StartProxy"</span>,<span class="attr">"Payload"</span>:&#123;<span class="attr">"Url"</span>:<span class="string">"http://qjw.ngrok.com:10080"</span>,<span class="attr">"ClientAddr"</span>:<span class="string">"127.0.0.1:52630"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>ngrok可以同时支持若干view，为了实时同步状态等数据，<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// the model sends updates through this broadcast channel</span></span><br><span class="line">    updates *util.Broadcast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBroadcast</span><span class="params">()</span> *<span class="title">Broadcast</span></span> &#123;</span><br><span class="line">    b := &amp;Broadcast&#123;</span><br><span class="line">        listeners: <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>),</span><br><span class="line">        reg:       <span class="built_in">make</span>(<span class="keyword">chan</span> (<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)),</span><br><span class="line">        unreg:     <span class="built_in">make</span>(<span class="keyword">chan</span> (<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)),</span><br><span class="line">        in:        <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="comment">// 取消注册</span></span><br><span class="line">            <span class="keyword">case</span> l := &lt;-b.unreg:</span><br><span class="line">                <span class="comment">// remove L from b.listeners</span></span><br><span class="line">                <span class="comment">// this operation is slow: O(n) but not used frequently</span></span><br><span class="line">                <span class="comment">// unlike iterating over listeners</span></span><br><span class="line">                oldListeners := b.listeners</span><br><span class="line">                b.listeners = <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(oldListeners))</span><br><span class="line">                <span class="comment">// 这个删除操作很蛋疼</span></span><br><span class="line">                <span class="keyword">for</span> _, oldL := <span class="keyword">range</span> oldListeners &#123;</span><br><span class="line">                    <span class="keyword">if</span> l != oldL &#123;</span><br><span class="line">                        b.listeners = <span class="built_in">append</span>(b.listeners, oldL)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 注册操作</span></span><br><span class="line">            <span class="keyword">case</span> l := &lt;-b.reg:</span><br><span class="line">                b.listeners = <span class="built_in">append</span>(b.listeners, l)</span><br><span class="line">            <span class="comment">// 刷新操作</span></span><br><span class="line">            <span class="keyword">case</span> item := &lt;-b.in:</span><br><span class="line">                <span class="keyword">for</span> _, l := <span class="keyword">range</span> b.listeners &#123;</span><br><span class="line">                    l &lt;- item</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外的刷新channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broadcast)</span> <span class="title">In</span><span class="params">()</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.in</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个注册channel，用于注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broadcast)</span> <span class="title">Reg</span><span class="params">()</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    listener := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    b.reg &lt;- listener</span><br><span class="line">    <span class="keyword">return</span> listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消注册一个channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broadcast)</span> <span class="title">UnReg</span><span class="params">(listener <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    b.unreg &lt;- listener</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctl *Controller)</span> <span class="title">Update</span><span class="params">(state mvc.State)</span></span> &#123;</span><br><span class="line">    ctl.updates.In() &lt;- state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWebView</span><span class="params">(ctl mvc.Controller, addr <span class="keyword">string</span>)</span> *<span class="title">WebView</span></span> &#123;</span><br><span class="line">    <span class="comment">// handle web socket connections</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/_ws"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 注册一个channel</span></span><br><span class="line">        msgs := wv.wsMessages.Reg()</span><br><span class="line">        <span class="comment">// 退出是取消注册</span></span><br><span class="line">        <span class="keyword">defer</span> wv.wsMessages.UnReg(msgs)</span><br><span class="line">        <span class="comment">// 监听这个channel</span></span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">            err := conn.WriteMessage(websocket.TextMessage, m.([]<span class="keyword">byte</span>))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// connection is closed</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> wv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拦截Http-Request-Response"><a href="#拦截Http-Request-Response" class="headerlink" title="拦截Http Request/Response"></a>拦截Http Request/Response</h1><p>为了支持view呈现，需要拦截获取经过客户端的所有req/resp</p>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>每种tunnel 会有一种protocol,代码定义在src/github.com/qjw/ngrok/src/ngrok/proto/</p>
<p>在初始化view时，会设置proto到view对象中<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, protocol := <span class="keyword">range</span> model.GetProtocols() &#123;</span><br><span class="line">    <span class="keyword">switch</span> p := protocol.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *proto.Http:</span><br><span class="line">        <span class="keyword">if</span> termView != <span class="literal">nil</span> &#123;</span><br><span class="line">            ctl.AddView(termView.NewHttpView(p))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> webView != <span class="literal">nil</span> &#123;</span><br><span class="line">            ctl.AddView(webView.NewHttpView(p))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *TermView)</span> <span class="title">NewHttpView</span><span class="params">(p *proto.Http)</span> *<span class="title">HttpView</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTermHttpView(v.ctl, v, p, <span class="number">0</span>, <span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wv *WebView)</span> <span class="title">NewHttpView</span><span class="params">(proto *proto.Http)</span> *<span class="title">WebHttpView</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newWebHttpView(wv.ctl, wv, proto)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p>以webview为例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWebHttpView</span><span class="params">(ctl mvc.Controller, wv *WebView, proto *proto.Http)</span> *<span class="title">WebHttpView</span></span> &#123;</span><br><span class="line">    whv := &amp;WebHttpView&#123;</span><br><span class="line">        Logger:       log.NewPrefixLogger(<span class="string">"view"</span>, <span class="string">"web"</span>, <span class="string">"http"</span>),</span><br><span class="line">        webview:      wv,</span><br><span class="line">        ctl:          ctl,</span><br><span class="line">        httpProto:    proto,</span><br><span class="line">        idToTxn:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*SerializedTxn),</span><br><span class="line">        HttpRequests: util.NewRing(<span class="number">20</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实时刷新</span></span><br><span class="line">    ctl.Go(whv.updateHttp)</span><br><span class="line">    whv.register()</span><br><span class="line">    <span class="keyword">return</span> whv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(whv *WebHttpView)</span> <span class="title">updateHttp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// open channels for incoming http state changes</span></span><br><span class="line">    <span class="comment">// and broadcasts</span></span><br><span class="line">    txnUpdates := whv.httpProto.Txns.Reg()</span><br><span class="line">    <span class="comment">// 监听whv.httpProto.Txns</span></span><br><span class="line">    <span class="keyword">for</span> txn := <span class="keyword">range</span> txnUpdates &#123;</span><br><span class="line">        <span class="comment">// 获得实际的对象</span></span><br><span class="line">        htxn := txn.(*proto.HttpTxn)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 。。。 刷新操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Http <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 可以看到Txns是一个广播对象</span></span><br><span class="line">    Txns     *util.Broadcast</span><br><span class="line">    reqGauge metrics.Gauge</span><br><span class="line">    reqMeter metrics.Meter</span><br><span class="line">    reqTimer metrics.Timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的代码中，会通过包装本地的conn<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">localConn := tunnel.Protocol.WrapConn(localConn, param)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Http)</span> <span class="title">WrapConn</span><span class="params">(c conn.Conn, ctx <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">conn</span>.<span class="title">Conn</span></span> &#123;</span><br><span class="line">    tee := conn.NewTee(c)</span><br><span class="line">    <span class="comment">// 用一个管道将获取Request和Response串起来</span></span><br><span class="line">    lastTxn := <span class="built_in">make</span>(<span class="keyword">chan</span> *HttpTxn)</span><br><span class="line">    <span class="comment">// 读取Request</span></span><br><span class="line">    <span class="keyword">go</span> h.readRequests(tee, lastTxn, ctx)</span><br><span class="line">    <span class="comment">// 读取Response</span></span><br><span class="line">    <span class="keyword">go</span> h.readResponses(tee, lastTxn)</span><br><span class="line">    <span class="keyword">return</span> tee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Http)</span> <span class="title">readRequests</span><span class="params">(tee *conn.Tee, lastTxn <span class="keyword">chan</span> *HttpTxn, connCtx <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(lastTxn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 不停地从tee的写tee中解析Request</span></span><br><span class="line">        req, err := http.ReadRequest(tee.WriteBuffer())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// no more requests to be read, we're done</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// golang's ReadRequest/DumpRequestOut is broken. Fix up the request so it works later</span></span><br><span class="line">        req.URL.Scheme = <span class="string">"http"</span></span><br><span class="line">        req.URL.Host = req.Host</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个HttpTxn对象</span></span><br><span class="line">        txn := &amp;HttpTxn&#123;Start: time.Now(), ConnUserCtx: connCtx&#125;</span><br><span class="line">        txn.Req = &amp;HttpRequest&#123;Request: req&#125;</span><br><span class="line">        <span class="keyword">if</span> req.Body != <span class="literal">nil</span> &#123;</span><br><span class="line">            txn.Req.BodyBytes, txn.Req.Body, err = extractBody(req.Body)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                tee.Warn(<span class="string">"Failed to extract request body: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到Req/Resp共享的channel，通知resp逻辑解析Response</span></span><br><span class="line">        lastTxn &lt;- txn</span><br><span class="line">        <span class="comment">// 通知view刷新</span></span><br><span class="line">        h.Txns.In() &lt;- txn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Http)</span> <span class="title">readResponses</span><span class="params">(tee *conn.Tee, lastTxn <span class="keyword">chan</span> *HttpTxn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> txn := <span class="keyword">range</span> lastTxn &#123;</span><br><span class="line">        <span class="comment">// 当req解析完之后，会触发resp解析</span></span><br><span class="line">        <span class="comment">// 从tee的读tee中不停地解析Response</span></span><br><span class="line">        resp, err := http.ReadResponse(tee.ReadBuffer(), txn.Req.Request)</span><br><span class="line">        txn.Duration = time.Since(txn.Start)</span><br><span class="line">        h.reqTimer.Update(txn.Duration)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            tee.Warn(<span class="string">"Error reading response from server: %v"</span>, err)</span><br><span class="line">            <span class="comment">// no more responses to be read, we're done</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新HttpTxn对象的Response</span></span><br><span class="line">        txn.Resp = &amp;HttpResponse&#123;Response: resp&#125;</span><br><span class="line">        <span class="comment">// apparently, Body can be nil in some cases</span></span><br><span class="line">        <span class="keyword">if</span> resp.Body != <span class="literal">nil</span> &#123;</span><br><span class="line">            txn.Resp.BodyBytes, txn.Resp.Body, err = extractBody(resp.Body)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                tee.Warn(<span class="string">"Failed to extract response body: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知view刷新</span></span><br><span class="line">        h.Txns.In() &lt;- txn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conn-Tee"><a href="#Conn-Tee" class="headerlink" title="Conn.Tee"></a>Conn.Tee</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTee</span><span class="params">(conn Conn)</span> *<span class="title">Tee</span></span> &#123;</span><br><span class="line">    c := &amp;Tee&#123;</span><br><span class="line">        rd:   <span class="literal">nil</span>,</span><br><span class="line">        wr:   <span class="literal">nil</span>,</span><br><span class="line">        Conn: conn,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.readPipe.rd, c.readPipe.wr = io.Pipe()</span><br><span class="line">    c.writePipe.rd, c.writePipe.wr = io.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取的时候，一并拷贝一份到c.readPipe.wr，那么c.readPipe.rd就可读</span></span><br><span class="line">    <span class="comment">// 参考ReadBuffer</span></span><br><span class="line">    c.rd = io.TeeReader(c.Conn, c.readPipe.wr)</span><br><span class="line">    <span class="comment">// 当写入的时候，一并写入c.writePipe.wr，那么c.writePipe.rz就可读</span></span><br><span class="line">    <span class="comment">// 参考WriteBuffer</span></span><br><span class="line">    c.wr = io.MultiWriter(c.Conn, c.writePipe.wr)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Tee)</span> <span class="title">ReadBuffer</span><span class="params">()</span> *<span class="title">bufio</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bufio.NewReader(c.readPipe.rd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Tee)</span> <span class="title">WriteBuffer</span><span class="params">()</span> *<span class="title">bufio</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bufio.NewReader(c.writePipe.rd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/05/ngrok/" data-id="ckdbgbyx7004243po1exilwmy" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/05/ngrok/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngrok/">ngrok</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-ngrokd" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/ngrokd/">Ngrok服务端源码学习笔记</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/05/ngrokd/" class="article-date"><time datetime="2017-07-05T11:32:49.000Z" itemprop="datePublished">2017-07-05</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码学习/">源码学习</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>关于ngrok的使用，参考<a href="http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/" target="_blank" rel="noopener">http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/</a></p>
<p>源码地址 <a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a>，我fork一份在<a href="https://github.com/qjw/ngrok" target="_blank" rel="noopener">https://github.com/qjw/ngrok</a>,代码相对路径<strong>src/github.com/qjw/ngrok/src/ngrok/server/</strong>。</p>
<p>main入口在<strong>src/github.com/qjw/ngrok/src/ngrok/main</strong>,分成客户端和服务端/ngrokd/ngrokd.go、/ngrok/ngrok.go。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cli.go  命令行相关</span><br><span class="line">├── control.go 客户端和服务端控制连接逻辑</span><br><span class="line">├── http.go 处理来自公网的http（s）的请求逻辑</span><br><span class="line">├── main.go 入口</span><br><span class="line">├── metrics.go 一些统计相关的东西</span><br><span class="line">├── registry.go  存储全局对象的<span class="string">"容器"</span></span><br><span class="line">├── tls.go tls加密相关</span><br><span class="line">└── tunnel.go 客户端和服务端隧道逻辑</span><br></pre></td></tr></table></figure>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>在了解ngrok服务器原理之前，有几个术语需要区分</p>
<ol>
<li>controller，控制器，每个客户端对应一个controller，并且会绑定一条tcp连接，默认使用tls加密，代码逻辑control.go，conroller用于传输各种控制指令</li>
<li>tunnel，隧道，一个客户端到服务端有多个隧道，每个隧道有个<strong>TYPE</strong>，例如http、https、tcp，以及<strong>URL</strong>，例如test.ngrok.qiujinwu.com【<em>假设ngrok.qiujinwu.com绑定到了服务器</em>】。在服务端代码中，tunnel是个虚拟的实体，并没有绑定的tcp连接。当收到来自公网的请求时，会根据隧道url来匹配客户端</li>
<li>proxy，表示客户端到服务端的数据链路，根据外网请求的多少，客户端到服务端会有多个proxy</li>
<li>listener，tcp服务器，默认会开启（http/https/tunnel三个tcp服务器，tcp类型不明确）</li>
</ol>
<h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><p>在controller中，会发送各种控制指令，这些指令定义在<strong>src/github.com/qjw/ngrok/src/ngrok/msg/msg.go</strong>，大体而言可以分为三类</p>
<ol>
<li>控制指令，用于客户端连接服务器的协商报文</li>
<li>proxy指令，用于服务器请求新的数据链路（<strong>由于客户端属于内网，ngrok服务器无法主动建立到客户端的连接，所以服务器会先走控制连接通知客户端，让它发起数据连接请求</strong>）</li>
<li>心跳</li>
</ol>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化比较简单，把报文序列化成字符串，并且把报文名称放在最前面，代码<strong>src/github.com/qjw/ngrok/src/ngrok/msg/pack.go</strong>，例如<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"RegProxy"</span>,<span class="attr">"Payload"</span>:&#123;<span class="attr">"ClientId"</span>:<span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>src/github.com/qjw/ngrok/src/ngrok/msg/conn.go有一些从tcp连接（反）序列化的工具函数</p>
<h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GLOBALS</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 所有的tunnel</span></span><br><span class="line">	tunnelRegistry  *TunnelRegistry</span><br><span class="line">	<span class="comment">// 所有的controller</span></span><br><span class="line">	controlRegistry *ControlRegistry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 参数</span></span><br><span class="line">	opts	  *Options</span><br><span class="line">	<span class="comment">// 所有的tcp服务器</span></span><br><span class="line">	listeners <span class="keyword">map</span>[<span class="keyword">string</span>]*conn.Listener</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ControlRegistry maps a client ID to Control structures</span></span><br><span class="line"><span class="keyword">type</span> ControlRegistry <span class="keyword">struct</span> &#123;</span><br><span class="line">	controls <span class="keyword">map</span>[<span class="keyword">string</span>]*Control</span><br><span class="line">	log.Logger</span><br><span class="line">	sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TunnelRegistry maps a tunnel URL to Tunnel structures</span></span><br><span class="line"><span class="keyword">type</span> TunnelRegistry <span class="keyword">struct</span> &#123;</span><br><span class="line">	tunnels  <span class="keyword">map</span>[<span class="keyword">string</span>]*Tunnel</span><br><span class="line">	affinity *cache.LRUCache</span><br><span class="line">	log.Logger</span><br><span class="line">	sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tunnel <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// request that opened the tunnel</span></span><br><span class="line">	req *msg.ReqTunnel</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 关联到control</span></span><br><span class="line">	ctl *Control</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><p>在服务器接收请求之前，会新建一个listenr，这个对象对tcp服务器进行了封装</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>src/github.com/qjw/ngrok/src/ngrok/conn/conn.go<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Listener <span class="keyword">struct</span> &#123;</span><br><span class="line">	net.Addr</span><br><span class="line">	<span class="comment">// 将请求accept的新tcp连接放入channel</span></span><br><span class="line">	Conns <span class="keyword">chan</span> *loggedConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggedConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	tcp *net.TCPConn</span><br><span class="line">	net.Conn</span><br><span class="line">	log.Logger</span><br><span class="line">	id  <span class="keyword">int32</span></span><br><span class="line">	typ <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将net.TCPConn包装成loggedConn，用于区分日志，设置type，id等<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapConn</span><span class="params">(conn net.Conn, typ <span class="keyword">string</span>)</span> *<span class="title">loggedConn</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c := conn.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *vhost.HTTPConn:</span><br><span class="line">		wrapped := c.Conn.(*loggedConn)</span><br><span class="line">		<span class="keyword">return</span> &amp;loggedConn&#123;wrapped.tcp, conn, wrapped.Logger, wrapped.id, wrapped.typ&#125;</span><br><span class="line">	<span class="keyword">case</span> *loggedConn:</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	<span class="keyword">case</span> *net.TCPConn:</span><br><span class="line">		wrapped := &amp;loggedConn&#123;c, conn, log.NewPrefixLogger(), rand.Int31(), typ&#125;</span><br><span class="line">		wrapped.AddLogPrefix(wrapped.Id())</span><br><span class="line">		<span class="keyword">return</span> wrapped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(l *Listener, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// listen for incoming connections</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="comment">// 。。。</span></span><br><span class="line">	l = &amp;Listener&#123;</span><br><span class="line">		Addr:  listener.Addr(),</span><br><span class="line">		Conns: <span class="built_in">make</span>(<span class="keyword">chan</span> *loggedConn),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			rawConn, err := listener.Accept()</span><br><span class="line">			c := wrapConn(rawConn, typ)</span><br><span class="line">			<span class="comment">// 新的连接放入channel</span></span><br><span class="line">			l.Conns &lt;- c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立tcp服务器</span></span><br><span class="line">	listener, err := conn.Listen(addr, <span class="string">"tun"</span>, tlsConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从channel中等待新的请求到来</span></span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">		<span class="comment">// 每个连接用新的goroutune</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tunnelConn conn.Conn)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="comment">// 自动处理异常</span></span><br><span class="line">				<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">					tunnelConn.Info(<span class="string">"tunnelListener failed with error %v: %s"</span>, r, debug.Stack())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 读取消息</span></span><br><span class="line">			<span class="keyword">var</span> rawMsg msg.Message</span><br><span class="line">			<span class="keyword">if</span> rawMsg, err = msg.ReadMsg(tunnelConn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.Auth:</span><br><span class="line">				<span class="comment">// 建立控制连接（controller）</span></span><br><span class="line">				NewControl(tunnelConn, m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> *msg.RegProxy:</span><br><span class="line">				<span class="comment">// 建立数据连接</span></span><br><span class="line">				NewProxy(tunnelConn, m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				tunnelConn.Close()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的请求报文<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"Auth"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"Version"</span>: <span class="string">"2"</span>,</span><br><span class="line">	<span class="attr">"MmVersion"</span>: <span class="string">"1.7"</span>,</span><br><span class="line">	<span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"Password"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"OS"</span>: <span class="string">"linux"</span>,</span><br><span class="line">	<span class="attr">"Arch"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">	<span class="attr">"ClientId"</span>: <span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"AuthResp"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"Version"</span>: <span class="string">"2"</span>,</span><br><span class="line">	<span class="attr">"MmVersion"</span>: <span class="string">"1.7"</span>,</span><br><span class="line">	<span class="attr">"ClientId"</span>: <span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span>,</span><br><span class="line">	<span class="attr">"Error"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create the object</span></span><br><span class="line">	c := &amp;Control&#123;</span><br><span class="line">		auth:			authMsg,</span><br><span class="line">		conn:			ctlConn,</span><br><span class="line">		out:			 <span class="built_in">make</span>(<span class="keyword">chan</span> msg.Message),</span><br><span class="line">		in:			  <span class="built_in">make</span>(<span class="keyword">chan</span> msg.Message),</span><br><span class="line">		proxies:		 <span class="built_in">make</span>(<span class="keyword">chan</span> conn.Conn, <span class="number">10</span>),</span><br><span class="line">		lastPing:		time.Now(),</span><br><span class="line">		writerShutdown:  util.NewShutdown(),</span><br><span class="line">		readerShutdown:  util.NewShutdown(),</span><br><span class="line">		managerShutdown: util.NewShutdown(),</span><br><span class="line">		shutdown:		util.NewShutdown(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置属性</span></span><br><span class="line">	ctlConn.SetType(<span class="string">"ctl"</span>)</span><br><span class="line">	ctlConn.AddLogPrefix(c.id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 版本判断</span></span><br><span class="line">	<span class="keyword">if</span> authMsg.Version != version.Proto &#123;</span><br><span class="line">		failAuth(fmt.Errorf(<span class="string">"Incompatible versions. Server %s, client %s. Download a new version at http://ngrok.com"</span>, version.MajorMinor(), authMsg.Version))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新增/更新control到全局Registry</span></span><br><span class="line">	<span class="keyword">if</span> replaced := controlRegistry.(c.id, c); replaced != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 等待旧的完全关闭</span></span><br><span class="line">		replaced.shutdown.WaitComplete()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新的goruntune监听写（需要最先开启，以便回复连接请求报文）</span></span><br><span class="line">	<span class="keyword">go</span> c.writer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回复连接建立确认报文</span></span><br><span class="line">	c.out &lt;- &amp;msg.AuthResp&#123;</span><br><span class="line">		Version:   version.Proto,</span><br><span class="line">		MmVersion: version.MajorMinor(),</span><br><span class="line">		ClientId:  c.id,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预先申请一个proxy连接</span></span><br><span class="line">	c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一堆其他的后台goroutune</span></span><br><span class="line">	<span class="keyword">go</span> c.manager()</span><br><span class="line">	<span class="keyword">go</span> c.reader()</span><br><span class="line">	<span class="keyword">go</span> c.stopper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送控制消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> m := <span class="keyword">range</span> c.out &#123;</span><br><span class="line">		<span class="keyword">if</span> err := msg.WriteMsg(c.conn, m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收控制消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg, err := msg.ReadMsg(c.conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				c.conn.Info(<span class="string">"EOF"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 推送到c.in channel中</span></span><br><span class="line">			c.in &lt;- msg</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检查control超时</span></span><br><span class="line">	reap := time.NewTicker(connReapInterval)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-reap.C:</span><br><span class="line">			<span class="comment">// 检查是否超时</span></span><br><span class="line">			<span class="keyword">if</span> time.Since(c.lastPing) &gt; pingTimeoutInterval &#123;</span><br><span class="line">				c.conn.Info(<span class="string">"Lost heartbeat"</span>)</span><br><span class="line">				c.shutdown.Begin()</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> mRaw, ok := &lt;-c.in:</span><br><span class="line">			<span class="comment">// 是否有新的消息</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> m := mRaw.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.ReqTunnel:</span><br><span class="line">				<span class="comment">// 客户端注册一个新的tunnel</span></span><br><span class="line">				c.registerTunnel(m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> *msg.Ping:</span><br><span class="line">				<span class="comment">// 回复心跳</span></span><br><span class="line">				c.lastPing = time.Now()</span><br><span class="line">				c.out &lt;- &amp;msg.Pong&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册controller<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControlRegistry)</span> <span class="title">Add</span><span class="params">(clientId <span class="keyword">string</span>, ctl *Control)</span> <span class="params">(oldCtl *Control)</span></span> &#123;</span><br><span class="line">	r.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.Unlock()</span><br><span class="line"></span><br><span class="line">	oldCtl = r.controls[clientId]</span><br><span class="line">	<span class="keyword">if</span> oldCtl != <span class="literal">nil</span> &#123;</span><br><span class="line">		oldCtl.Replaced(ctl)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.controls[clientId] = ctl</span><br><span class="line">	r.Info(<span class="string">"Registered control with id %s"</span>, clientId)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="退出流程"><a href="#退出流程" class="headerlink" title="退出流程"></a>退出流程</h3><p><strong>退出流程可以考虑用<a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">https://golang.org/pkg/context/</a>简化下</strong>，这里用到了一个util.Shutdown的工具库（src/github.com/qjw/ngrok/src/ngrok/util/shutdown.go）。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Control <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of writer()</span></span><br><span class="line">	writerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of reader()</span></span><br><span class="line">	readerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of manager()</span></span><br><span class="line">	managerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controller shutdown of entire Control</span></span><br><span class="line">	shutdown *util.Shutdown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// kill everything if the reader stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line">	<span class="comment">// notify that we're done</span></span><br><span class="line">	<span class="keyword">defer</span> c.readerShutdown.Complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// kill everything if the writer() stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that we've flushed all messages</span></span><br><span class="line">	<span class="keyword">defer</span> c.writerShutdown.Complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// kill everything if the control manager stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that manager() has shutdown</span></span><br><span class="line">	<span class="keyword">defer</span> c.managerShutdown.Complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个专门的goruntune来监听退出<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">stopper</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 等待</span></span><br><span class="line">	c.shutdown.WaitBegin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注销controller</span></span><br><span class="line">	controlRegistry.Del(c.id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待各种子goruntune注销</span></span><br><span class="line">	<span class="comment">// close会触发其他的goruntune退出</span></span><br><span class="line">	<span class="built_in">close</span>(c.in)</span><br><span class="line">	c.managerShutdown.WaitComplete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shutdown writer()</span></span><br><span class="line">	<span class="built_in">close</span>(c.out)</span><br><span class="line">	c.writerShutdown.WaitComplete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭空置连接</span></span><br><span class="line">	c.conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭各种tunnel</span></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> c.tunnels &#123;</span><br><span class="line">		<span class="comment">// 调用shutdown，</span></span><br><span class="line">		t.Shutdown()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭各种proxy连接</span></span><br><span class="line">	<span class="built_in">close</span>(c.proxies)</span><br><span class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> c.proxies &#123;</span><br><span class="line">		p.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终关闭</span></span><br><span class="line">	c.shutdown.Complete()</span><br><span class="line">	c.conn.Info(<span class="string">"Shutdown complete"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tunnel注册"><a href="#Tunnel注册" class="headerlink" title="Tunnel注册"></a>Tunnel注册</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register a new tunnel on this control connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">registerTunnel</span><span class="params">(rawTunnelReq *msg.ReqTunnel)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 若有多个tunnel，可以用一个报文一次性注册</span></span><br><span class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> strings.Split(rawTunnelReq.Protocol, <span class="string">"+"</span>) &#123;</span><br><span class="line">		tunnelReq := *rawTunnelReq</span><br><span class="line">		tunnelReq.Protocol = proto</span><br><span class="line"></span><br><span class="line">		c.conn.Debug(<span class="string">"Registering new tunnel"</span>)</span><br><span class="line">		t, err := NewTunnel(&amp;tunnelReq, c)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 回复注册失败确认</span></span><br><span class="line">			c.out &lt;- &amp;msg.NewTunnel&#123;Error: err.Error()&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注册到controller</span></span><br><span class="line">		c.tunnels = <span class="built_in">append</span>(c.tunnels, t)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回复注册成功确认</span></span><br><span class="line">		c.out &lt;- &amp;msg.NewTunnel&#123;</span><br><span class="line">			Url:	  t.url,</span><br><span class="line">			Protocol: proto,</span><br><span class="line">			ReqId:	rawTunnelReq.ReqId,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rawTunnelReq.Hostname = strings.Replace(t.url, proto+<span class="string">"://"</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的注册报文<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"ReqTunnel"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"ReqId"</span>: <span class="string">"dd1819bd088d7675"</span>,</span><br><span class="line">	<span class="attr">"Protocol"</span>: <span class="string">"http"</span>,</span><br><span class="line">	<span class="attr">"Hostname"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"Subdomain"</span>: <span class="string">"qjw"</span>,</span><br><span class="line">	<span class="attr">"HttpAuth"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"RemotePort"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"NewTunnel"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"ReqId"</span>: <span class="string">"dd1819bd088d7675"</span>,</span><br><span class="line">	<span class="attr">"Url"</span>: <span class="string">"http://qjw.ngrok.com:10080"</span>,</span><br><span class="line">	<span class="attr">"Protocol"</span>: <span class="string">"http"</span>,</span><br><span class="line">	<span class="attr">"Error"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new tunnel from a registration message received</span></span><br><span class="line"><span class="comment">// on a control channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTunnel</span><span class="params">(m *msg.ReqTunnel, ctl *Control)</span> <span class="params">(t *Tunnel, err error)</span></span> &#123;</span><br><span class="line">	t = &amp;Tunnel&#123;</span><br><span class="line">		req:	m,</span><br><span class="line">		start:  time.Now(),</span><br><span class="line">		ctl:	ctl,</span><br><span class="line">		Logger: log.NewPrefixLogger(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proto := t.req.Protocol</span><br><span class="line">	<span class="keyword">switch</span> proto &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"tcp"</span>:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"http"</span>, <span class="string">"https"</span>:</span><br><span class="line">		l, ok := listeners[proto]</span><br><span class="line">		<span class="comment">// 注册vhost，之所以v，是因为多个url共享同一个端口，类似于nginx的server</span></span><br><span class="line">		<span class="keyword">if</span> err = registerVhost(t, proto, l.Addr.(*net.TCPAddr).Port); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	t.AddLogPrefix(t.Id())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要确认vhost的参数，最重要的host，port，这对于公网连接的请求路由至关重要<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultPortMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"http"</span>:  <span class="number">80</span>,</span><br><span class="line">	<span class="string">"https"</span>: <span class="number">443</span>,</span><br><span class="line">	<span class="string">"smtp"</span>:  <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Common functionality for registering virtually hosted protocols</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerVhost</span><span class="params">(t *Tunnel, protocol <span class="keyword">string</span>, servingPort <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	vhost := os.Getenv(<span class="string">"VHOST"</span>)</span><br><span class="line">	<span class="keyword">if</span> vhost == <span class="string">""</span> &#123;</span><br><span class="line">		vhost = fmt.Sprintf(<span class="string">"%s:%d"</span>, opts.domain, servingPort)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Canonicalize virtual host by removing default port (e.g. :80 on HTTP)</span></span><br><span class="line">	defaultPort, ok := defaultPortMap[protocol]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Couldn't find default port for protocol %s"</span>, protocol)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移除默认的端口（比如80可以忽略，81就必须明确地出现在连接中）</span></span><br><span class="line">	defaultPortSuffix := fmt.Sprintf(<span class="string">":%d"</span>, defaultPort)</span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(vhost, defaultPortSuffix) &#123;</span><br><span class="line">		vhost = vhost[<span class="number">0</span> : <span class="built_in">len</span>(vhost)-<span class="built_in">len</span>(defaultPortSuffix)]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Canonicalize by always using lower-case</span></span><br><span class="line">	vhost = strings.ToLower(vhost)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从请求中获取host</span></span><br><span class="line">	hostname := strings.ToLower(strings.TrimSpace(t.req.Hostname))</span><br><span class="line">	<span class="keyword">if</span> hostname != <span class="string">""</span> &#123;</span><br><span class="line">		t.url = fmt.Sprintf(<span class="string">"%s://%s"</span>, protocol, hostname)</span><br><span class="line">		<span class="comment">// 注册tunnel</span></span><br><span class="line">		<span class="keyword">return</span> tunnelRegistry.Register(t.url, t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未指定host，指定了subdomain，就通过服务器启动参数domain来拼装host</span></span><br><span class="line">	subdomain := strings.ToLower(strings.TrimSpace(t.req.Subdomain))</span><br><span class="line">	<span class="keyword">if</span> subdomain != <span class="string">""</span> &#123;</span><br><span class="line">		t.url = fmt.Sprintf(<span class="string">"%s://%s.%s"</span>, protocol, subdomain, vhost)</span><br><span class="line">		<span class="comment">// 注册tunnel</span></span><br><span class="line">		<span class="keyword">return</span> tunnelRegistry.Register(t.url, t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 随机生成一个url</span></span><br><span class="line">	t.url, err = tunnelRegistry.RegisterRepeat(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s://%x.%s"</span>, protocol, rand.Int31(), vhost)</span><br><span class="line">	&#125;, t)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取消注册</span></span><br><span class="line">	tunnelRegistry.Del(t.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>在连接建立之后，服务器就会预先请求一个proxy<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"ReqProxy"</span>,<span class="attr">"Payload"</span>:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个clientid非常重要，用于关联到controller<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"RegProxy"</span>,<span class="attr">"Payload"</span>:&#123;<span class="attr">"ClientId"</span>:<span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 预先申请一个proxy</span></span><br><span class="line">	c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tunnelConn conn.Conn)</span></span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.RegProxy:</span><br><span class="line">				<span class="comment">// 新增一个proxy</span></span><br><span class="line">				NewProxy(tunnelConn, m)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proxy并没有全局的对象来注册，而是简单地关联到controller（通过之前的clientid），具体就是通过一个带缓存的channel<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Control <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// proxy connections</span></span><br><span class="line">	proxies <span class="keyword">chan</span> conn.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	c := &amp;Control&#123;</span><br><span class="line">		<span class="comment">// 10个元素的channel</span></span><br><span class="line">		proxies:		 <span class="built_in">make</span>(<span class="keyword">chan</span> conn.Conn, <span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxy</span><span class="params">(pxyConn conn.Conn, regPxy *msg.RegProxy)</span></span> &#123;</span><br><span class="line">	pxyConn.SetType(<span class="string">"pxy"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询controller</span></span><br><span class="line">	ctl := controlRegistry.Get(regPxy.ClientId)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册</span></span><br><span class="line">	ctl.RegisterProxy(pxyConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要获取proxy时，就直接调用下面的函数<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">GetProxy</span><span class="params">()</span> <span class="params">(proxyConn conn.Conn, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// get a proxy connection from the pool</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 直接从channel中获取</span></span><br><span class="line">	<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//  没有的话，立即请求客户端</span></span><br><span class="line">		<span class="keyword">if</span> err = util.PanicToError(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.out &lt;- &amp;msg.ReqProxy&#123;&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 继续从channle中获取</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(pingTimeoutInterval):</span><br><span class="line">			err = fmt.Errorf(<span class="string">"Timeout trying to get proxy connection"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="处理公网请求"><a href="#处理公网请求" class="headerlink" title="处理公网请求"></a>处理公网请求</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// listen for http</span></span><br><span class="line">	<span class="keyword">if</span> opts.httpAddr != <span class="string">""</span> &#123;</span><br><span class="line">		listeners[<span class="string">"http"</span>] = startHttpListener(opts.httpAddr, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Listens for new http(s) connections from the public internet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHttpListener</span><span class="params">(addr <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(listener *conn.Listener)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建服务器</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> listener, err = conn.Listen(addr, <span class="string">"pub"</span>, tlsCfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proto := <span class="string">"http"</span></span><br><span class="line">	<span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">		proto = <span class="string">"https"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">"Listening for public %s connections on %v"</span>, proto, listener.Addr.String())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> conn := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">			<span class="comment">// 每个连接都会调用下面的goruntune</span></span><br><span class="line">			<span class="keyword">go</span> httpHandler(conn, proto)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(c conn.Conn, proto <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取Http头</span></span><br><span class="line">	vhostConn, err := vhost.HTTP(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Warn(<span class="string">"Failed to read valid %s request: %v"</span>, proto, err)</span><br><span class="line">		c.Write([]<span class="keyword">byte</span>(BadRequest))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取http参数</span></span><br><span class="line">	host := strings.ToLower(vhostConn.Host())</span><br><span class="line">	auth := vhostConn.Request.Header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// done reading mux data, free up the request memory</span></span><br><span class="line">	vhostConn.Free()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need to read from the vhost conn now since it mucked around reading the stream</span></span><br><span class="line">	c = conn.Wrap(vhostConn, <span class="string">"pub"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从全局的Registry中查找tunnel</span></span><br><span class="line">	tunnel := tunnelRegistry.Get(fmt.Sprintf(<span class="string">"%s://%s"</span>, proto, host))</span><br><span class="line">	<span class="keyword">if</span> tunnel == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Info(<span class="string">"No tunnel found for hostname %s"</span>, host)</span><br><span class="line">		c.Write([]<span class="keyword">byte</span>(fmt.Sprintf(NotFound, <span class="built_in">len</span>(host)+<span class="number">18</span>, host)))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查认证</span></span><br><span class="line">	<span class="keyword">if</span> tunnel.req.HttpAuth != <span class="string">""</span> &amp;&amp; auth != tunnel.req.HttpAuth &#123;</span><br><span class="line">		c.Info(<span class="string">"Authentication failed: %s"</span>, auth)</span><br><span class="line">		c.Write([]<span class="keyword">byte</span>(NotAuthorized))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据交换</span></span><br><span class="line">	tunnel.HandlePublicConnection(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Http头"><a href="#Http头" class="headerlink" title="Http头"></a>Http头</h2><p>在数据交换过程中，为了作请求路由，必须先从路由中解析Http头（不考虑tcp tunnel），然后根据http头来作数据路由，而读出来的头，也必须原原本本的下发到客户端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	initVhostBufSize = <span class="number">1024</span> <span class="comment">// allocate 1 KB up front to try to avoid resizing</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sharedConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	net.Conn			   <span class="comment">// the raw connection</span></span><br><span class="line">	vhostBuf *bytes.Buffer <span class="comment">// all of the initial data that has to be read in order to vhost a connection is saved here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newShared</span><span class="params">(conn net.Conn)</span> <span class="params">(*sharedConn, io.Reader)</span></span> &#123;</span><br><span class="line">	c := &amp;sharedConn&#123;</span><br><span class="line">		Conn:	 conn,</span><br><span class="line">		<span class="comment">// 分配一块内存，用于存储http头，以便原原本本的下发到客户端</span></span><br><span class="line">		vhostBuf: bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, initVhostBufSize)),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当从conn读取数据后，复制一份到vhostBuf</span></span><br><span class="line">	<span class="keyword">return</span> c, io.TeeReader(conn, c.vhostBuf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *sharedConn)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="comment">// 已经读取到内存中的数据已经发送完</span></span><br><span class="line">	<span class="keyword">if</span> c.vhostBuf == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Unlock()</span><br><span class="line">		<span class="keyword">return</span> c.Conn.Read(p)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优先从buf中读取</span></span><br><span class="line">	n, err = c.vhostBuf.Read(p)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// end of the request buffer</span></span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="comment">// let the request buffer get garbage collected</span></span><br><span class="line">		<span class="comment">// and make sure we don't read from it again</span></span><br><span class="line">		c.vhostBuf = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读了一半继续从con中读取</span></span><br><span class="line">		<span class="comment">// continue reading from the connection</span></span><br><span class="line">		<span class="keyword">var</span> n2 <span class="keyword">int</span></span><br><span class="line">		n2, err = c.Conn.Read(p[n:])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// update total read</span></span><br><span class="line">		n += n2</span><br><span class="line">	&#125;</span><br><span class="line">	c.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vhost.HTTP<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HTTP</span><span class="params">(conn net.Conn)</span> <span class="params">(httpConn *HTTPConn, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个tee的conn</span></span><br><span class="line">	c, rd := newShared(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析Http头，不得不说go的系统库很牛X</span></span><br><span class="line">	httpConn = &amp;HTTPConn&#123;sharedConn: c&#125;</span><br><span class="line">	<span class="keyword">if</span> httpConn.Request, err = http.ReadRequest(bufio.NewReader(rd)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// body不需要</span></span><br><span class="line">	httpConn.Request.Body.Close()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于有了sharedConn这一层封装，在数据交换时，完全可以不考虑，一部分数据已经为了解析http头而实现读取出来过的细节</p>
<h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">HandlePublicConnection</span><span class="params">(publicConn conn.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">2</span> * proxyMaxPoolSize); i++ &#123;</span><br><span class="line">		<span class="comment">// 获取一个proxy</span></span><br><span class="line">		<span class="keyword">if</span> proxyConn, err = t.ctl.GetProxy(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Warn(<span class="string">"Failed to get proxy connection: %v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自动关闭和设置属性</span></span><br><span class="line">		<span class="keyword">defer</span> proxyConn.Close()</span><br><span class="line">		t.Info(<span class="string">"Got proxy connection %s"</span>, proxyConn.Id())</span><br><span class="line">		proxyConn.AddLogPrefix(t.Id())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送数据，提示开始传输数据</span></span><br><span class="line">		startPxyMsg := &amp;msg.StartProxy&#123;</span><br><span class="line">			Url:		t.url,</span><br><span class="line">			ClientAddr: publicConn.RemoteAddr().String(),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err = msg.WriteMsg(proxyConn, startPxyMsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			proxyConn.Warn(<span class="string">"Failed to write StartProxyMessage: %v, attempt %d"</span>, err, i)</span><br><span class="line">			proxyConn.Close()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// success</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 立即申请一个新的proxy</span></span><br><span class="line">	util.PanicToError(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.ctl.out &lt;- &amp;msg.ReqProxy&#123;&#125; &#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换数据</span></span><br><span class="line">	bytesIn, bytesOut := conn.Join(publicConn, proxyConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个join实现双向的数据交换，<strong>这个地方可以做一些部分优化，直接从内核到内核传数据，参考<a href="https://linux.die.net/man/2/sendfile" target="_blank" rel="noopener">sendfile</a>、<a href="https://linux.die.net/man/2/splice" target="_blank" rel="noopener">splice</a></strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(c Conn, c2 Conn)</span> <span class="params">(<span class="keyword">int64</span>, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	pipe := <span class="function"><span class="keyword">func</span><span class="params">(to Conn, from Conn, bytesCopied *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> to.Close()</span><br><span class="line">		<span class="keyword">defer</span> from.Close()</span><br><span class="line">		<span class="keyword">defer</span> wait.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="comment">// 这个地方可以优化，在内部有一个应用层的buf作中转</span></span><br><span class="line">		*bytesCopied, err = io.Copy(to, from)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			from.Warn(<span class="string">"Copied %d bytes to %s before failing with error %v"</span>, *bytesCopied, to.Id(), err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			from.Debug(<span class="string">"Copied %d bytes to %s"</span>, *bytesCopied, to.Id())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wait.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">var</span> fromBytes, toBytes <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// 开启两个goruntune来实现双向交换</span></span><br><span class="line">	<span class="keyword">go</span> pipe(c, c2, &amp;fromBytes)</span><br><span class="line">	<span class="keyword">go</span> pipe(c2, c, &amp;toBytes)</span><br><span class="line">	c.Info(<span class="string">"Joined with connection %s"</span>, c2.Id())</span><br><span class="line">	wait.Wait()</span><br><span class="line">	<span class="keyword">return</span> fromBytes, toBytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="tls加密"><a href="#tls加密" class="headerlink" title="tls加密"></a>tls加密</h1><p>对于tls支持，go系统库支持的非常好，参考<a href="http://colobu.com/2016/06/07/simple-golang-tls-examples/" target="_blank" rel="noopener">http://colobu.com/2016/06/07/simple-golang-tls-examples/</a></p>
<p>ngrok有点讨巧，用系统库的工具函数在tcp裸连接做了一层包装<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(l *Listener, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听tcp端口</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明对象</span></span><br><span class="line">	l = &amp;Listener&#123;</span><br><span class="line">		Addr:  listener.Addr(),</span><br><span class="line">		Conns: <span class="built_in">make</span>(<span class="keyword">chan</span> *loggedConn),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			rawConn, err := listener.Accept()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理新连接</span></span><br><span class="line">			c := wrapConn(rawConn, typ)</span><br><span class="line">			<span class="comment">// 若指定了tls配置（https tunnel必需）</span></span><br><span class="line">			<span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 直接将原来的裸tcp conn替换成被tls包装过的conn，所有的read/write会被tls层先做加工再下发</span></span><br><span class="line">				c.Conn = tls.Server(c.Conn, tlsCfg)</span><br><span class="line">			&#125;</span><br><span class="line">			l.Conns &lt;- c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>在ngrok客户端也是同样的逻辑<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(conn *loggedConn, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rawConn net.Conn</span><br><span class="line">	<span class="keyword">if</span> rawConn, err = net.Dial(<span class="string">"tcp"</span>, addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn = wrapConn(rawConn, typ)</span><br><span class="line">	conn.Debug(<span class="string">"New connection to: %v"</span>, rawConn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若指定了tls配置（https tunnel必需）</span></span><br><span class="line">	<span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">		conn.StartTLS(tlsCfg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loggedConn)</span> <span class="title">StartTLS</span><span class="params">(tlsCfg *tls.Config)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 直接将原来的裸tcp conn替换成被tls包装过的conn，所有的read/write会被tls层先做加工再下发</span></span><br><span class="line">	c.Conn = tls.Client(c.Conn, tlsCfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/05/ngrokd/" data-id="ckdbgbyxa004543pom79l223o" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/05/ngrokd/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngrok/">ngrok</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-golang-anonymous-member" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/golang-anonymous-member/">Golang 匿名对象指针和对象的区别</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/03/golang-anonymous-member/" class="article-date"><time datetime="2017-07-03T04:23:11.000Z" itemprop="datePublished">2017-07-03</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>都说<strong>一图胜千言</strong>，有代码就不废话了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">	Animal</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Ppersion <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	animal := Animal&#123;Name: <span class="string">"Cat"</span>&#125;</span><br><span class="line">	persion := Persion&#123;animal&#125;</span><br><span class="line">	ppersion := Ppersion&#123;&amp;animal&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Animal:"</span> + animal.Name)</span><br><span class="line">	fmt.Println(<span class="string">"Persion:"</span> + persion.Name)</span><br><span class="line">	fmt.Println(<span class="string">"PPersion:"</span> + ppersion.Name)</span><br><span class="line"></span><br><span class="line">	animal.Name = <span class="string">"Dog"</span></span><br><span class="line">	fmt.Println(<span class="string">"------------我是卖萌分割线------------"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Animal:"</span> + animal.Name)</span><br><span class="line">	fmt.Println(<span class="string">"Persion:"</span> + persion.Name)</span><br><span class="line">	fmt.Println(persion.Animal == animal)</span><br><span class="line">	fmt.Println(<span class="string">"PPersion:"</span> + ppersion.Name)</span><br><span class="line">	fmt.Println(ppersion.Animal == &amp;animal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Animal:Cat</span><br><span class="line">Persion:Cat</span><br><span class="line">PPersion:Cat</span><br><span class="line">------------我是卖萌分割线------------</span><br><span class="line">Animal:Dog</span><br><span class="line">Persion:Cat</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">PPersion:Dog</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="struct-interface转换"><a href="#struct-interface转换" class="headerlink" title="struct/interface转换"></a>struct/interface转换</h1><p>下面的代码会报错，因为Stduent未实现People的接口，实现People接口的是*People，所以改法有两种</p>
<ol>
<li>var peo People = &amp;Stduent{} # 用指针赋值给People</li>
<li>func (stu Stduent) Speak(think string) (talk string) # Stduent对象实现Speak方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	Speak(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stduent <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Stduent)</span> <span class="title">Speak</span><span class="params">(think <span class="keyword">string</span>)</span> <span class="params">(talk <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> think == <span class="string">"bitch"</span> &#123;</span><br><span class="line">		talk = <span class="string">"You are a good boy"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		talk = <span class="string">"hi"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> peo People = Stduent&#123;&#125;</span><br><span class="line">	think := <span class="string">"bitch"</span></span><br><span class="line">	fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h1><p>下面的代码调用的是People.ShowB，因为go没有类似于C++的多态机制</p>
<blockquote>
<p>Go中没有继承！ 没有继承！没有继承！是叫组合！组合！组合！<br>这里People是匿名组合People。被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法，但他们的方法(ShowA())调用时接受者并没有发生变化。<br>这里仍然是People。毕竟这个People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。<br>因此这里执行t.ShowA()时，在执行ShowB()时该函数的接受者是People，而非Teacher。具体参见<a href="https://golang.org/doc/effective_go.html#Embedding" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">ShowA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"showA"</span>)</span><br><span class="line">	p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"showB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"teacher showB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := Teacher&#123;&#125;</span><br><span class="line">	t.ShowA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://segmentfault.com/q/1010000002687684" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002687684</a></li>
<li><a href="https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html" target="_blank" rel="noopener">https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html</a></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/03/golang-anonymous-member/" data-id="ckdbgbyw6002143po6d07px3f" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/03/golang-anonymous-member/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-golang-httptest" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/golang-httptest/">Golang Http调试</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/06/28/golang-httptest/" class="article-date"><time datetime="2017-06-28T11:13:21.000Z" itemprop="datePublished">2017-06-28</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Go Http包的处理函数如下，一个用于输入(Request)，一个用于输出（Response)，很多第三方的web框架都提供了自己的处理函数定义，但都很方便地适配HandlerFunc<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure></p>
<p>为了调试，http包提供了ResponseWriter/Request的模拟</p>
<h1 id="httptest"><a href="#httptest" class="headerlink" title="httptest"></a>httptest</h1><ol>
<li>httptest.NewRequest 用于模拟一个Request请求</li>
<li>httptest.NewRecorder用于模拟一个Response</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httptest"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		io.WriteString(w, <span class="string">"&lt;html&gt;&lt;body&gt;Hello World!["</span> + r.URL.String() + <span class="string">"]&lt;/body&gt;&lt;/html&gt;"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req := httptest.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com/foo"</span>, <span class="literal">nil</span>)</span><br><span class="line">	w := httptest.NewRecorder()</span><br><span class="line">	handler(w, req)</span><br><span class="line"></span><br><span class="line">	resp := w.Result()</span><br><span class="line">	body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">	fmt.Println(resp.StatusCode)</span><br><span class="line">	fmt.Println(resp.Header.Get(<span class="string">"Content-Type"</span>))</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// 200</span></span><br><span class="line">	<span class="comment">// text/html; charset=utf-8</span></span><br><span class="line">	<span class="comment">// &lt;html&gt;&lt;body&gt;Hello World![http://example.com/foo]&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>处理模拟请求和响应，Httptest同样提供了服务器的模拟，不过非常简单，没有路由，只能提供单个响应函数（<em>在响应函数自行处理另当别论</em>）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httptest"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ts := httptest.NewServer(http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">"Hello, client"</span>)</span><br><span class="line">	&#125;))</span><br><span class="line">	<span class="keyword">defer</span> ts.Close()</span><br><span class="line"></span><br><span class="line">	res, err := http.Get(ts.URL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	greeting, err := ioutil.ReadAll(res.Body)</span><br><span class="line">	res.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%s"</span>, greeting)</span><br><span class="line">	<span class="comment">// Output: Hello, client</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>server提供了几个接口，用法有一些简单的区别<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewServer starts and returns a new Server.</span></span><br><span class="line"><span class="comment">// The caller should call Close when finished, to shut it down.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(handler http.Handler)</span> *<span class="title">Server</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUnstartedServer returns a new Server but doesn't start it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After changing its configuration, the caller should call Start or</span></span><br><span class="line"><span class="comment">// StartTLS.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The caller should call Close when finished, to shut it down.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnstartedServer</span><span class="params">(handler http.Handler)</span> *<span class="title">Server</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTLSServer starts and returns a new Server using TLS.</span></span><br><span class="line"><span class="comment">// The caller should call Close when finished, to shut it down.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTLSServer</span><span class="params">(handler http.Handler)</span> *<span class="title">Server</span></span></span><br></pre></td></tr></table></figure></p>
<p>启动服务器，并不会阻塞当前gorounte，在内部会开启一个新的gorounte来执行监听任务<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">goServe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s.wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> s.wg.Done()</span><br><span class="line">		s.Config.Serve(s.Listener)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="httptrace"><a href="#httptrace" class="headerlink" title="httptrace"></a>httptrace</h1><p>此外，http还包含httptrace，用于监听http请求的各种事件，核心就是一个ClientTrace对象，具体的函数，可以godoc<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httptest"</span></span><br><span class="line">	<span class="string">"net/http/httptrace"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := httptest.NewServer(http.HandlerFunc(http.NotFound))</span><br><span class="line">	<span class="keyword">defer</span> server.Close()</span><br><span class="line">	c := http.Client&#123;&#125;</span><br><span class="line">	req, err := http.NewRequest(<span class="string">"GET"</span>, server.URL, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace := &amp;httptrace.ClientTrace&#123;</span><br><span class="line">		GotConn: <span class="function"><span class="keyword">func</span><span class="params">(connInfo httptrace.GotConnInfo)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Got Conn"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		ConnectStart: <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Dial start"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		ConnectDone: <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Dial done"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		GotFirstResponseByte: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"First response byte!"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		WroteHeaders: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Wrote headers"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		WroteRequest: <span class="function"><span class="keyword">func</span><span class="params">(wr httptrace.WroteRequestInfo)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Wrote request"</span>, wr)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))</span><br><span class="line">	fmt.Println(<span class="string">"Starting request!"</span>)</span><br><span class="line">	resp, err := c.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	io.Copy(os.Stdout, resp.Body)</span><br><span class="line">	fmt.Println(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://golang.org/src/net/http/httptest/example_test.go" target="_blank" rel="noopener">https://golang.org/src/net/http/httptest/example_test.go</a></li>
<li><a href="https://golang.org/pkg/net/http/httptrace/" target="_blank" rel="noopener">https://golang.org/pkg/net/http/httptrace/</a></li>
<li><a href="http://www.tuicool.com/articles/nQzqmuZ" target="_blank" rel="noopener">http://www.tuicool.com/articles/nQzqmuZ</a></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/06/28/golang-httptest/" data-id="ckdbgbywa002d43po7r319vk3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/06/28/golang-httptest/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-golang-context" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/23/golang-context/">Golang Context</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/06/23/golang-context/" class="article-date"><time datetime="2017-06-23T14:23:11.000Z" itemprop="datePublished">2017-06-23</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>从go1.7开始，golang.org/x/net/context包正式作为context包进入了标准库。官方的说明如下</p>
<blockquote>
<p>Package context defines the Context type, which carries deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.</p>
</blockquote>
<p>参考</p>
<ol>
<li><a href="https://blog.golang.org/context" target="_blank" rel="noopener">https://blog.golang.org/context</a></li>
<li><a href="https://godoc.org/golang.org/x/net/context" target="_blank" rel="noopener">https://godoc.org/golang.org/x/net/context</a></li>
</ol>
<p>Context接口非常简单<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, a cancelation signal, and other values across</span></span><br><span class="line"><span class="comment">// API boundaries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context's methods may be called by multiple goroutines simultaneously.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 是否有超时，超时context才有</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 是否已经结束，通过从channel中读取数据判断，用于被监听的routine</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 当Done返回的ch读取数据（或者被close），可以获取到错误（取消，超时等）</span></span><br><span class="line">	Err() error</span><br><span class="line">    <span class="comment">// value Context的值，通过key获取</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Context的核心通过channel来作同步，为了理解，最好了解go的同步机制</p>
<h1 id="Go语言并发模型"><a href="#Go语言并发模型" class="headerlink" title="Go语言并发模型"></a><a href="Go语言并发模型：像Unix Pipe那样使用channel">Go语言并发模型</a></h1><p>参考<a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">Go Concurrency Patterns: Pipelines and cancellation</a></p>
<p>和其他语言相比，go对并发的控制源于非常简单，但功能并不弱，常用的包括（但不限于）</p>
<ol>
<li>sync.Mutex 互斥</li>
<li>sync.WaitGroup</li>
<li>channel</li>
</ol>
<p>官方推荐channel，并且对此有很好的优化</p>
<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><p>连续单个的管道<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			out &lt;- n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">			out &lt;- n * n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置流水线</span></span><br><span class="line">	c := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	out := sq(c)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 消费输出结果</span></span><br><span class="line">	fmt.Println(&lt;-out) <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(&lt;-out) <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个并行的pipe并行处理，并汇聚到下一个pipe，核心是sync.WaitGroup作屏障<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			out &lt;- n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">			out &lt;- n * n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每一个输入channel cs 创建一个 goroutine output</span></span><br><span class="line">	<span class="comment">// output 将数据从 c 拷贝到 out，直到 c 关闭，然后 调用 wg.Done</span></span><br><span class="line">	output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">			out &lt;- n</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">		<span class="keyword">go</span> output(c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动一个 goroutine，用于所有 output goroutine结束时，关闭 out </span></span><br><span class="line">	<span class="comment">// 该goroutine 必须在 wg.Add 之后启动</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	in := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动两个 sq 实例，即两个goroutines处理 channel "in" 的数据</span></span><br><span class="line">	c1 := sq(in)</span><br><span class="line">	c2 := sq(in)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// merge 函数将 channel c1 和 c2 合并到一起，这段代码会消费 merge 的结果</span></span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> merge(c1, c2) &#123;</span><br><span class="line">		fmt.Println(n) <span class="comment">// 打印 4 9, 或 9 4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h2><p>通过传递一个用于控制是否退出的channel来实现和谐的中断，这也是Context的核心所在，为了控制多个channel，只需要<strong>close channel写端</strong>即可唤醒所有的channel读端<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 cs 的每一个 channel 创建一个 goroutine</span></span><br><span class="line">    <span class="comment">// 这个 goroutine 运行 output，它将数据从 c</span></span><br><span class="line">    <span class="comment">// 拷贝到 out，直到 c 关闭，或者 接收到 done</span></span><br><span class="line">    <span class="comment">// 的关闭信号。人啊后调用 wg.Done()</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- n:</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>关于中断多个channel，参考<a href="https://chilts.org/2017/06/12/cancelling-multiple-goroutines" target="_blank" rel="noopener">https://chilts.org/2017/06/12/cancelling-multiple-goroutines</a></p>
<p>channel作为一种同步机制，有必要了解go的内存模型和（非）缓存的同步差异</p>
<h1 id="go内存模型"><a href="#go内存模型" class="headerlink" title="go内存模型"></a><a href="http://blog.csdn.net/ywh147/article/details/10942603" target="_blank" rel="noopener">go内存模型</a></h1><p>参考<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p>
<h2 id="Happens-Before-After"><a href="#Happens-Before-After" class="headerlink" title="Happens Before/After"></a>Happens Before/After</h2><p>Happens-before用来指明Go程序里的内存操作的局部顺序。如果一个内存操作事件e1 happens-before e2，则e2 happens-after e1也成立；如果e1不是happens-before e2,也不是happens-after e2，则e1和e2是并发的。</p>
<p>下面这段是核心，也很费解</p>
<blockquote>
<p>在这个定义之下，如果以下情况满足，则对变量（v）的内存写操作（w）对一个内存读操作（r）来说允许可见的：</p>
<ol>
<li>r不在w开始之前发生（可以是之后或并发）；</li>
<li>w和r之间没有另一个写操作(w’)发生；</li>
</ol>
</blockquote>
<blockquote>
<p>为了保证对变量（v）的一个特定写操作（w）对一个读操作（r）可见，就需要确保w是r唯一允许的写操作，于是如果以下情况满足，则对变量（v）的内存写操作（w）对一个内存读操作（r）来说保证可见的：</p>
<ol>
<li>w在r开始之前发生；</li>
<li>所有其它对v的写操作只在w之前或r之后发生；</li>
</ol>
</blockquote>
<p>简单地说，对于【<strong>允许可见</strong>】表示有可能读到正确的写数据，但是由于存在读脏数据的可能，（假定读操作是有意义的）所以极端情况，编译器甚至优化掉写代码逻辑</p>
<p>而【<strong>保证可见</strong>】就确保一定能读到正确的写数据，所以编译器会确保写操作在读操作前执行</p>
<h2 id="Channel-同步"><a href="#Channel-同步" class="headerlink" title="Channel 同步"></a>Channel 同步</h2><ol>
<li>对一个Channel的发送操作(send) happens-before 相应Channel的接收操作完成</li>
<li>关闭一个Channel happens-before 从该Channel接收到最后的返回值0</li>
<li>不带缓冲的Channel的接收操作（receive） happens-before 相应Channel的发送操作完成</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span></span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可以确保输出hello, world，因为【a = “hello, world”】 <strong>happens-before</strong> 【c &lt;- 0】，【print(a)】 <strong>happens-after</strong> 【&lt;-c】， 根据上面的规则1）以及happens-before的可传递性，a = “hello, world” happens-beforeprint(a)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span></span><br><span class="line">	<span class="built_in">close</span>(c) <span class="comment">///////</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据规则2）把c&lt;-0替换成close(c)也能保证输出hello,world，因为关闭操作在&lt;-c接收到0之前发送。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span></span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据规则3），因为c是不带缓冲的【Channel，a = “hello, world”】 <strong>happens-before</strong> 【&lt;-c】 <strong>happens-before</strong> 【&lt;- 0】 <strong>happens-before</strong> 【print(a)】， </p>
<p><strong>但如果c是缓冲队列，如定义c = make(chan int, 1), 那结果就不确定了。</strong></p>
<h1 id="Context-解决的问题"><a href="#Context-解决的问题" class="headerlink" title="Context 解决的问题"></a>Context 解决的问题</h1><p>在并发模型中，经常会开启几个go routine来并发处理任务，这就提出了能够中断（取消）的需求，虽然前面提到的方案都是可行的（实际上Context也就是对上述方案的封装），但抽象得并不好，</p>
<p>还有一个很大的问题是，如果调用的go routine内部又开启了多个go routine，如何和谐的递归触发中断呢？</p>
<p>除了中断，另外一个常见的需求是超时，以及传递参数</p>
<blockquote>
<p>go routine可以直接传参数，Context valueCtx的优势在于，父routine的value可以继承到子routine（若key不冲突），只需要（以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位。）</p>
</blockquote>
<p>为此，Context提供了几个工具函数<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>WithTimeout对WithDeadline的一个简单转换封装，就是相对时间/绝对实际的差别，它继承自CancelCtx</li>
<li>CancelCtx是可以取消Context，另一个参数是一个函数，调用函数实际上就是关闭（close）Done的channel。</li>
<li>Context提供了空Context（emptyCtx），无实际意义，除了做了根Context</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> e &#123;</span><br><span class="line">	<span class="keyword">case</span> background:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"context.Background"</span></span><br><span class="line">	<span class="keyword">case</span> todo:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"context.TODO"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"unknown empty Context"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">	todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>参考<a href="http://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">http://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">				time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Context控制多个goroutine<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name,<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name,<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">"【监控1】"</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">"【监控2】"</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">"【监控3】"</span>)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CancelCtx"><a href="#CancelCtx" class="headerlink" title="CancelCtx"></a>CancelCtx</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed by the first cancel call.</span></span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex</span><br><span class="line">    <span class="comment">// 管理routine树状结构（bool无意义，只因无类似stl set的数据结构）</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">bool</span> <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    <span class="comment">// 退出后，标记原因的err</span></span><br><span class="line">	err      error             <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// 用于子Routine监听退出的channel</span></span><br><span class="line">	<span class="keyword">return</span> c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chilren存的是一个canceler接口<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// cancel确保可以递归的cancel子routine</span></span><br><span class="line">	cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    <span class="comment">// 参见propagateCancel</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭接口"><a href="#关闭接口" class="headerlink" title="关闭接口"></a>关闭接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="comment">// 返回的第二个参数是调用了cancel函数的函数</span></span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel closes c.done, cancels each of c's children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent's children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">    <span class="comment">// 设置了err就表示已经cancel过，不能重复cancel</span></span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">    <span class="comment">// 关闭channel，唤醒所有监听的子routine</span></span><br><span class="line">	<span class="built_in">close</span>(c.done)</span><br><span class="line">    <span class="comment">// 递归cancel子 routine</span></span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里作为一个bool参数，是因为并非每种ctx都需要removeChild。比如valueCtx就不需要，它只能寄居在另外两种里面</span></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正因为如此，所以提供了工具函数，不停地网上遍历，找到最近的一个具有chilren的context<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *cancelCtx:</span><br><span class="line">			<span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *timerCtx:  <span class="comment">// 人家继承自cancelCtx</span></span><br><span class="line">			<span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *valueCtx:</span><br><span class="line">			parent = c.Context</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从父context中删除就使用了这个工具函数，也就是说他并不是他parent的child<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// removeChild removes a context from its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里的p并不一定是他的直接parent</span></span><br><span class="line">	p, ok := parentCancelCtx(parent)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// propagateCancel arranges <span class="keyword">for</span> child to be canceled when parent is.</span><br><span class="line">func propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">    // parent无可退出，那自认也就不能包含什么chilren</span><br><span class="line">	<span class="keyword">if</span> parent.Done() == nil &#123;</span><br><span class="line">		<span class="built_in">return</span> // parent is never canceled</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != nil &#123;</span><br><span class="line">            // parent已经cancel，立即cancel child</span><br><span class="line">			// parent has already been canceled</span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	//  构建context树</span><br><span class="line">			<span class="keyword">if</span> p.children == nil &#123;</span><br><span class="line">				p.children = make(map[canceler]bool)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	// 按理不会走到这里来，既然parent.Done()不为空，那么肯定实现了cancel/timerCtx</span><br><span class="line">        // 然后到为了确保自行扩展导致的异常情况？？？？？</span><br><span class="line">		go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前的过期时间比parent还后，那么就不需要过期了，简单地做个cancelCtx就行了</span></span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  deadline,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	d := deadline.Sub(time.Now())</span><br><span class="line">	<span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 立即执行</span></span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 回调执行</span></span><br><span class="line">		c.timer = time.AfterFunc(d, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span></span><br><span class="line"><span class="comment">// delegates all other calls to the embedded Context.</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithValue(%#v, %#v)"</span>, c.Context, c.key, c.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 往上递归，实现累加传递参数</span></span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/06/23/golang-context/" data-id="ckdbgbyw9002943potdbr5m3j" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/06/23/golang-context/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-godoc" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/22/godoc/">Golang文档</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/06/22/godoc/" class="article-date"><time datetime="2017-06-22T12:23:16.000Z" itemprop="datePublished">2017-06-22</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang/">Golang</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Godoc"><a href="#Godoc" class="headerlink" title="Godoc"></a>Godoc</h1><p>Godoc 的概念同 Python 的 <a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">Docstring</a> 和 Java 的 <a href="http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html" target="_blank" rel="noopener">Javadoc</a>类似，但是设计上更为简单。</p>
<p>如果需要将注释转化成HTML形式的文档，Godoc用户还需要掌握一些额外的格式化规则：</p>
<ol>
<li>段落以空行格开</li>
<li>预格式化的文档应该缩进（参考gob包的<a href="http://golang.org/src/pkg/encoding/gob/doc.go" target="_blank" rel="noopener">doc.go</a>）</li>
<li>URL将被转化为HTML链接，无需其它的特殊标记</li>
</ol>
<h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h2><p>go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ godoc fmt Printf</span><br><span class="line">use <span class="string">'godoc cmd/fmt'</span> <span class="keyword">for</span> documentation on the fmt <span class="built_in">command</span> </span><br><span class="line"></span><br><span class="line">func Printf(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    Printf formats according to a format specifier and writes to standard</span><br><span class="line">    output. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ go doc fmt Printf</span><br><span class="line">func Printf(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    Printf formats according to a format specifier and writes to standard</span><br><span class="line">    output. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure>
<p>也可以处理当前目录下的模块<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ go doc Add2</span><br><span class="line">func Add2(a, b int) int</span><br><span class="line">    一个加法实现 返回a+b的值</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ go doc bb</span><br><span class="line">package bb // import <span class="string">"test/bb"</span></span><br><span class="line"></span><br><span class="line">提供的常用库，有一些常用的方法，方便使用</span><br><span class="line"></span><br><span class="line">提供的常用库，有一些常用的方法，方便使用1222</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int</span><br><span class="line">func Add2(a, b int) int</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>标记名称</th>
<th>标记描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>加入此标记后会使go doc命令区分参数中字母的大小写。默认情况下，命令是大小写不敏感的。</td>
</tr>
<tr>
<td>-cmd</td>
<td>加入此标记后会使go doc命令同时打印出main包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的。</td>
</tr>
<tr>
<td>-u</td>
<td>加入此标记后会使go doc命令同时打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的。</td>
</tr>
</tbody>
</table>
<h2 id="godoc"><a href="#godoc" class="headerlink" title="godoc"></a>godoc</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ godoc fmt</span><br><span class="line">use <span class="string">'godoc cmd/fmt'</span> <span class="keyword">for</span> documentation on the fmt <span class="built_in">command</span> </span><br><span class="line"></span><br><span class="line">PACKAGE DOCUMENTATION</span><br><span class="line"></span><br><span class="line">package fmt</span><br><span class="line">    import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    Package fmt implements formatted I/O with <span class="built_in">functions</span> analogous to C<span class="string">'s</span></span><br><span class="line"><span class="string">    printf and scanf. The format '</span>verbs<span class="string">' are derived from C'</span>s but are</span><br><span class="line">    simpler.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ godoc fmt Printf</span><br><span class="line">use <span class="string">'godoc cmd/fmt'</span> <span class="keyword">for</span> documentation on the fmt <span class="built_in">command</span> </span><br><span class="line"></span><br><span class="line">func Printf(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    Printf formats according to a format specifier and writes to standard</span><br><span class="line">    output. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">king@king:~/code/go/src/<span class="built_in">test</span>$ godoc fmt Printf Println</span><br><span class="line">use <span class="string">'godoc cmd/fmt'</span> <span class="keyword">for</span> documentation on the fmt <span class="built_in">command</span> </span><br><span class="line"></span><br><span class="line">func Printf(format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    Printf formats according to a format specifier and writes to standard</span><br><span class="line">    output. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br><span class="line"></span><br><span class="line">func Println(a ...interface&#123;&#125;) (n int, err error)</span><br><span class="line">    Println formats using the default formats <span class="keyword">for</span> its operands and writes to</span><br><span class="line">    standard output. Spaces are always added between operands and a newline</span><br><span class="line">    is appended. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure>
<p>最牛叉的是http命令，可以直接打开浏览器看文档和代码，生成的文档包含本机GOPATH下的所有代码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">godoc -http=:6060</span><br></pre></td></tr></table></figure></p>
<h1 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h1><p>对于Resful Api，用swagger ui可以很好的组织和测试接口，请参考项目<a href="https://github.com/qjw/go-swagger-doc" target="_blank" rel="noopener">https://github.com/qjw/go-swagger-doc</a></p>
<h1 id="Doxygen"><a href="#Doxygen" class="headerlink" title="Doxygen"></a>Doxygen</h1><p>Doxygen是一种开源跨平台的，以类似JavaDoc风格描述的文档系统，完全支持C、C++、Java、Objective-C和IDL语言，部分支持PHP、C#。注释的语法与Qt-Doc、KDoc和JavaDoc兼容。</p>
<p>参考旧文<a href="http://qjw.qiujinwu.com/blog/2013/06/02/doxygen_study" target="_blank" rel="noopener">http://qjw.qiujinwu.com/blog/2013/06/02/doxygen_study</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://octman.com/blog/2014-02-24-godoc-documenting-go-code/" target="_blank" rel="noopener">http://octman.com/blog/2014-02-24-godoc-documenting-go-code/</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/go-command-tutorial/0.5.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/go-command-tutorial/0.5.html</a></li>
<li><a href="https://mikespook.com/2011/04/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91godoc%EF%BC%9A%E6%96%87%E6%A1%A3%E5%8C%96-go-%E4%BB%A3%E7%A0%81/" target="_blank" rel="noopener">https://mikespook.com/2011/04/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91godoc%EF%BC%9A%E6%96%87%E6%A1%A3%E5%8C%96-go-%E4%BB%A3%E7%A0%81/</a></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/06/22/godoc/" data-id="ckdbgbyw3001s43pols56beuo" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/06/22/godoc/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>


    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="active"><span class="page-number">4</span></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-number" href="/page/7/">7</a></li><li><a class="page-next" rel="next" href="/page/5/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-2 col-sm-offset-1 blog-sidebar">
          
  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Golang/">Golang</a><span class="sidebar-module-list-count">14</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Openldap/">Openldap</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Python/">Python</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/后端/">后端</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/学习笔记/">学习笔记</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/开发环境/">开发环境</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/源码学习/">源码学习</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/环境搭建/">环境搭建</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/运营运维/">运营运维</a><span class="sidebar-module-list-count">10</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/运营运维/代理/">代理</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/运营运维/网站/">网站</a><span class="sidebar-module-list-count">1</span></li></ul></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ansible/">ansible</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/antd/">antd</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/cookie/">cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/cors/">cors</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/crsf/">crsf</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/docker/">docker</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/drone/">drone</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/elasticsearch/">elasticsearch</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/flask/">flask</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/git/">git</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/github/">github</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/gitlab/">gitlab</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/golang/">golang</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/gorm/">gorm</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grpc/">grpc</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/hexo/">hexo</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/influxdb/">influxdb</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/jsonp/">jsonp</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/jsonschema/">jsonschema</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/kibana/">kibana</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/martini/">martini</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/nginx/">nginx</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ngrok/">ngrok</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/node/">node</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/openldap/">openldap</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/pip/">pip</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/proxy/">proxy</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/python/">python</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/redis/">redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/sentry/">sentry</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/sqlalchemy/">sqlalchemy</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ssh/">ssh</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/sso/">sso</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/tars/">tars</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/tavern/">tavern</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/travis/">travis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/uml/">uml</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/wcgi/">wcgi</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/xss/">xss</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/一致性hash/">一致性hash</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/持续集成/">持续集成</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/盗链/">盗链</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/签名/">签名</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/证书/">证书</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/antd/" style="font-size: 10px;">antd</a> <a href="/tags/cookie/" style="font-size: 11.67px;">cookie</a> <a href="/tags/cors/" style="font-size: 10px;">cors</a> <a href="/tags/crsf/" style="font-size: 10px;">crsf</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/drone/" style="font-size: 16.67px;">drone</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/flask/" style="font-size: 11.67px;">flask</a> <a href="/tags/git/" style="font-size: 11.67px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/gitlab/" style="font-size: 11.67px;">gitlab</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/gorm/" style="font-size: 10px;">gorm</a> <a href="/tags/grpc/" style="font-size: 10px;">grpc</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/influxdb/" style="font-size: 10px;">influxdb</a> <a href="/tags/jsonp/" style="font-size: 10px;">jsonp</a> <a href="/tags/jsonschema/" style="font-size: 10px;">jsonschema</a> <a href="/tags/kibana/" style="font-size: 10px;">kibana</a> <a href="/tags/martini/" style="font-size: 10px;">martini</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/ngrok/" style="font-size: 11.67px;">ngrok</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/openldap/" style="font-size: 13.33px;">openldap</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/proxy/" style="font-size: 13.33px;">proxy</a> <a href="/tags/python/" style="font-size: 11.67px;">python</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/sentry/" style="font-size: 11.67px;">sentry</a> <a href="/tags/sqlalchemy/" style="font-size: 10px;">sqlalchemy</a> <a href="/tags/ssh/" style="font-size: 11.67px;">ssh</a> <a href="/tags/sso/" style="font-size: 10px;">sso</a> <a href="/tags/tars/" style="font-size: 10px;">tars</a> <a href="/tags/tavern/" style="font-size: 10px;">tavern</a> <a href="/tags/travis/" style="font-size: 10px;">travis</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a> <a href="/tags/wcgi/" style="font-size: 10px;">wcgi</a> <a href="/tags/xss/" style="font-size: 10px;">xss</a> <a href="/tags/一致性hash/" style="font-size: 10px;">一致性hash</a> <a href="/tags/持续集成/" style="font-size: 18.33px;">持续集成</a> <a href="/tags/盗链/" style="font-size: 10px;">盗链</a> <a href="/tags/签名/" style="font-size: 11.67px;">签名</a> <a href="/tags/证书/" style="font-size: 11.67px;">证书</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">八月 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">六月 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">三月 2020</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">二月 2020</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">一月 2020</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">四月 2017</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">三月 2017</a><span class="sidebar-module-list-count">10</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">二月 2017</a><span class="sidebar-module-list-count">10</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2020/08/01/gitlab-sentry/">gitlab/sentry集成</a>
        </li>
      
        <li>
          <a href="/2020/06/10/ansible/">Ansible实践</a>
        </li>
      
        <li>
          <a href="/2020/03/08/elasticsearch_basic/">ElasticSearch学习笔记</a>
        </li>
      
        <li>
          <a href="/2020/02/29/jaeger_basic/">Jaeger初探</a>
        </li>
      
        <li>
          <a href="/2020/02/20/tavern/">ResfulApi测试框架tavern</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2020 KingQiu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      <br/>
      CopyRight © 2019 <a href="http://beian.miit.gov.cn/" target="_blank">粤ICP备19068003号</a>
    </div>
  </div>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  
<script>
  var disqus_shortname = 'blog-qiujinwu-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js" crossorigin="anonymous"></script>

<script src="http://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
