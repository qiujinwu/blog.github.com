<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="google-site-verification" content="6jvcY_UrCpp1JLjXITf45ljboLU0NDGF16ZqomMt-ls">
  
  <title>Ngrok服务端源码学习笔记 | 个人笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关于ngrok的使用，参考http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/ 源码地址 https://github.com/inconshreveable/ngrok，我fork一份在https://github.com/qjw/ngrok,代码相对路径src/github.com/qjw/ngrok/src/ngrok/server">
<meta name="keywords" content="golang,ngrok">
<meta property="og:type" content="article">
<meta property="og:title" content="Ngrok服务端源码学习笔记">
<meta property="og:url" content="http://blog.kimq.cn/2017/07/05/ngrokd/index.html">
<meta property="og:site_name" content="个人笔记">
<meta property="og:description" content="关于ngrok的使用，参考http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/ 源码地址 https://github.com/inconshreveable/ngrok，我fork一份在https://github.com/qjw/ngrok,代码相对路径src/github.com/qjw/ngrok/src/ngrok/server">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-08-01T09:26:24.727Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ngrok服务端源码学习笔记">
<meta name="twitter:description" content="关于ngrok的使用，参考http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/ 源码地址 https://github.com/inconshreveable/ngrok，我fork一份在https://github.com/qjw/ngrok,代码相对路径src/github.com/qjw/ngrok/src/ngrok/server">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>
</html>
<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
          <li><a class=""
                 href="/atom.xml">Rss</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">个人笔记</h1>
  
    <p class="lead blog-description">专注互联网</p>
  
</div>

    <div class="row">
        <div class="col-sm-9 blog-main">
          <article id="post-ngrokd" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Ngrok服务端源码学习笔记
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2017/07/05/ngrokd/" class="article-date"><time datetime="2017-07-05T11:32:49.000Z" itemprop="datePublished">2017-07-05</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/源码学习/">源码学习</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>关于ngrok的使用，参考<a href="http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/" target="_blank" rel="noopener">http://blog.qiujinwu.com/2017/02/13/ngrok-reverse-proxy/</a></p>
<p>源码地址 <a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a>，我fork一份在<a href="https://github.com/qjw/ngrok" target="_blank" rel="noopener">https://github.com/qjw/ngrok</a>,代码相对路径<strong>src/github.com/qjw/ngrok/src/ngrok/server/</strong>。</p>
<p>main入口在<strong>src/github.com/qjw/ngrok/src/ngrok/main</strong>,分成客户端和服务端/ngrokd/ngrokd.go、/ngrok/ngrok.go。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cli.go  命令行相关</span><br><span class="line">├── control.go 客户端和服务端控制连接逻辑</span><br><span class="line">├── http.go 处理来自公网的http（s）的请求逻辑</span><br><span class="line">├── main.go 入口</span><br><span class="line">├── metrics.go 一些统计相关的东西</span><br><span class="line">├── registry.go  存储全局对象的<span class="string">"容器"</span></span><br><span class="line">├── tls.go tls加密相关</span><br><span class="line">└── tunnel.go 客户端和服务端隧道逻辑</span><br></pre></td></tr></table></figure>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>在了解ngrok服务器原理之前，有几个术语需要区分</p>
<ol>
<li>controller，控制器，每个客户端对应一个controller，并且会绑定一条tcp连接，默认使用tls加密，代码逻辑control.go，conroller用于传输各种控制指令</li>
<li>tunnel，隧道，一个客户端到服务端有多个隧道，每个隧道有个<strong>TYPE</strong>，例如http、https、tcp，以及<strong>URL</strong>，例如test.ngrok.qiujinwu.com【<em>假设ngrok.qiujinwu.com绑定到了服务器</em>】。在服务端代码中，tunnel是个虚拟的实体，并没有绑定的tcp连接。当收到来自公网的请求时，会根据隧道url来匹配客户端</li>
<li>proxy，表示客户端到服务端的数据链路，根据外网请求的多少，客户端到服务端会有多个proxy</li>
<li>listener，tcp服务器，默认会开启（http/https/tunnel三个tcp服务器，tcp类型不明确）</li>
</ol>
<h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><p>在controller中，会发送各种控制指令，这些指令定义在<strong>src/github.com/qjw/ngrok/src/ngrok/msg/msg.go</strong>，大体而言可以分为三类</p>
<ol>
<li>控制指令，用于客户端连接服务器的协商报文</li>
<li>proxy指令，用于服务器请求新的数据链路（<strong>由于客户端属于内网，ngrok服务器无法主动建立到客户端的连接，所以服务器会先走控制连接通知客户端，让它发起数据连接请求</strong>）</li>
<li>心跳</li>
</ol>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化比较简单，把报文序列化成字符串，并且把报文名称放在最前面，代码<strong>src/github.com/qjw/ngrok/src/ngrok/msg/pack.go</strong>，例如<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"RegProxy"</span>,<span class="attr">"Payload"</span>:&#123;<span class="attr">"ClientId"</span>:<span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>src/github.com/qjw/ngrok/src/ngrok/msg/conn.go有一些从tcp连接（反）序列化的工具函数</p>
<h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GLOBALS</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 所有的tunnel</span></span><br><span class="line">	tunnelRegistry  *TunnelRegistry</span><br><span class="line">	<span class="comment">// 所有的controller</span></span><br><span class="line">	controlRegistry *ControlRegistry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 参数</span></span><br><span class="line">	opts	  *Options</span><br><span class="line">	<span class="comment">// 所有的tcp服务器</span></span><br><span class="line">	listeners <span class="keyword">map</span>[<span class="keyword">string</span>]*conn.Listener</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ControlRegistry maps a client ID to Control structures</span></span><br><span class="line"><span class="keyword">type</span> ControlRegistry <span class="keyword">struct</span> &#123;</span><br><span class="line">	controls <span class="keyword">map</span>[<span class="keyword">string</span>]*Control</span><br><span class="line">	log.Logger</span><br><span class="line">	sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TunnelRegistry maps a tunnel URL to Tunnel structures</span></span><br><span class="line"><span class="keyword">type</span> TunnelRegistry <span class="keyword">struct</span> &#123;</span><br><span class="line">	tunnels  <span class="keyword">map</span>[<span class="keyword">string</span>]*Tunnel</span><br><span class="line">	affinity *cache.LRUCache</span><br><span class="line">	log.Logger</span><br><span class="line">	sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tunnel <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// request that opened the tunnel</span></span><br><span class="line">	req *msg.ReqTunnel</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 关联到control</span></span><br><span class="line">	ctl *Control</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><p>在服务器接收请求之前，会新建一个listenr，这个对象对tcp服务器进行了封装</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>src/github.com/qjw/ngrok/src/ngrok/conn/conn.go<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Listener <span class="keyword">struct</span> &#123;</span><br><span class="line">	net.Addr</span><br><span class="line">	<span class="comment">// 将请求accept的新tcp连接放入channel</span></span><br><span class="line">	Conns <span class="keyword">chan</span> *loggedConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggedConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	tcp *net.TCPConn</span><br><span class="line">	net.Conn</span><br><span class="line">	log.Logger</span><br><span class="line">	id  <span class="keyword">int32</span></span><br><span class="line">	typ <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将net.TCPConn包装成loggedConn，用于区分日志，设置type，id等<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapConn</span><span class="params">(conn net.Conn, typ <span class="keyword">string</span>)</span> *<span class="title">loggedConn</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c := conn.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *vhost.HTTPConn:</span><br><span class="line">		wrapped := c.Conn.(*loggedConn)</span><br><span class="line">		<span class="keyword">return</span> &amp;loggedConn&#123;wrapped.tcp, conn, wrapped.Logger, wrapped.id, wrapped.typ&#125;</span><br><span class="line">	<span class="keyword">case</span> *loggedConn:</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	<span class="keyword">case</span> *net.TCPConn:</span><br><span class="line">		wrapped := &amp;loggedConn&#123;c, conn, log.NewPrefixLogger(), rand.Int31(), typ&#125;</span><br><span class="line">		wrapped.AddLogPrefix(wrapped.Id())</span><br><span class="line">		<span class="keyword">return</span> wrapped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(l *Listener, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// listen for incoming connections</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="comment">// 。。。</span></span><br><span class="line">	l = &amp;Listener&#123;</span><br><span class="line">		Addr:  listener.Addr(),</span><br><span class="line">		Conns: <span class="built_in">make</span>(<span class="keyword">chan</span> *loggedConn),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			rawConn, err := listener.Accept()</span><br><span class="line">			c := wrapConn(rawConn, typ)</span><br><span class="line">			<span class="comment">// 新的连接放入channel</span></span><br><span class="line">			l.Conns &lt;- c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立tcp服务器</span></span><br><span class="line">	listener, err := conn.Listen(addr, <span class="string">"tun"</span>, tlsConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从channel中等待新的请求到来</span></span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">		<span class="comment">// 每个连接用新的goroutune</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tunnelConn conn.Conn)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="comment">// 自动处理异常</span></span><br><span class="line">				<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">					tunnelConn.Info(<span class="string">"tunnelListener failed with error %v: %s"</span>, r, debug.Stack())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 读取消息</span></span><br><span class="line">			<span class="keyword">var</span> rawMsg msg.Message</span><br><span class="line">			<span class="keyword">if</span> rawMsg, err = msg.ReadMsg(tunnelConn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.Auth:</span><br><span class="line">				<span class="comment">// 建立控制连接（controller）</span></span><br><span class="line">				NewControl(tunnelConn, m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> *msg.RegProxy:</span><br><span class="line">				<span class="comment">// 建立数据连接</span></span><br><span class="line">				NewProxy(tunnelConn, m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				tunnelConn.Close()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的请求报文<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"Auth"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"Version"</span>: <span class="string">"2"</span>,</span><br><span class="line">	<span class="attr">"MmVersion"</span>: <span class="string">"1.7"</span>,</span><br><span class="line">	<span class="attr">"User"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"Password"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"OS"</span>: <span class="string">"linux"</span>,</span><br><span class="line">	<span class="attr">"Arch"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">	<span class="attr">"ClientId"</span>: <span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"AuthResp"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"Version"</span>: <span class="string">"2"</span>,</span><br><span class="line">	<span class="attr">"MmVersion"</span>: <span class="string">"1.7"</span>,</span><br><span class="line">	<span class="attr">"ClientId"</span>: <span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span>,</span><br><span class="line">	<span class="attr">"Error"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create the object</span></span><br><span class="line">	c := &amp;Control&#123;</span><br><span class="line">		auth:			authMsg,</span><br><span class="line">		conn:			ctlConn,</span><br><span class="line">		out:			 <span class="built_in">make</span>(<span class="keyword">chan</span> msg.Message),</span><br><span class="line">		in:			  <span class="built_in">make</span>(<span class="keyword">chan</span> msg.Message),</span><br><span class="line">		proxies:		 <span class="built_in">make</span>(<span class="keyword">chan</span> conn.Conn, <span class="number">10</span>),</span><br><span class="line">		lastPing:		time.Now(),</span><br><span class="line">		writerShutdown:  util.NewShutdown(),</span><br><span class="line">		readerShutdown:  util.NewShutdown(),</span><br><span class="line">		managerShutdown: util.NewShutdown(),</span><br><span class="line">		shutdown:		util.NewShutdown(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置属性</span></span><br><span class="line">	ctlConn.SetType(<span class="string">"ctl"</span>)</span><br><span class="line">	ctlConn.AddLogPrefix(c.id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 版本判断</span></span><br><span class="line">	<span class="keyword">if</span> authMsg.Version != version.Proto &#123;</span><br><span class="line">		failAuth(fmt.Errorf(<span class="string">"Incompatible versions. Server %s, client %s. Download a new version at http://ngrok.com"</span>, version.MajorMinor(), authMsg.Version))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新增/更新control到全局Registry</span></span><br><span class="line">	<span class="keyword">if</span> replaced := controlRegistry.(c.id, c); replaced != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 等待旧的完全关闭</span></span><br><span class="line">		replaced.shutdown.WaitComplete()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新的goruntune监听写（需要最先开启，以便回复连接请求报文）</span></span><br><span class="line">	<span class="keyword">go</span> c.writer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回复连接建立确认报文</span></span><br><span class="line">	c.out &lt;- &amp;msg.AuthResp&#123;</span><br><span class="line">		Version:   version.Proto,</span><br><span class="line">		MmVersion: version.MajorMinor(),</span><br><span class="line">		ClientId:  c.id,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预先申请一个proxy连接</span></span><br><span class="line">	c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一堆其他的后台goroutune</span></span><br><span class="line">	<span class="keyword">go</span> c.manager()</span><br><span class="line">	<span class="keyword">go</span> c.reader()</span><br><span class="line">	<span class="keyword">go</span> c.stopper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送控制消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> m := <span class="keyword">range</span> c.out &#123;</span><br><span class="line">		<span class="keyword">if</span> err := msg.WriteMsg(c.conn, m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收控制消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg, err := msg.ReadMsg(c.conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				c.conn.Info(<span class="string">"EOF"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 推送到c.in channel中</span></span><br><span class="line">			c.in &lt;- msg</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检查control超时</span></span><br><span class="line">	reap := time.NewTicker(connReapInterval)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-reap.C:</span><br><span class="line">			<span class="comment">// 检查是否超时</span></span><br><span class="line">			<span class="keyword">if</span> time.Since(c.lastPing) &gt; pingTimeoutInterval &#123;</span><br><span class="line">				c.conn.Info(<span class="string">"Lost heartbeat"</span>)</span><br><span class="line">				c.shutdown.Begin()</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> mRaw, ok := &lt;-c.in:</span><br><span class="line">			<span class="comment">// 是否有新的消息</span></span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> m := mRaw.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.ReqTunnel:</span><br><span class="line">				<span class="comment">// 客户端注册一个新的tunnel</span></span><br><span class="line">				c.registerTunnel(m)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> *msg.Ping:</span><br><span class="line">				<span class="comment">// 回复心跳</span></span><br><span class="line">				c.lastPing = time.Now()</span><br><span class="line">				c.out &lt;- &amp;msg.Pong&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册controller<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControlRegistry)</span> <span class="title">Add</span><span class="params">(clientId <span class="keyword">string</span>, ctl *Control)</span> <span class="params">(oldCtl *Control)</span></span> &#123;</span><br><span class="line">	r.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.Unlock()</span><br><span class="line"></span><br><span class="line">	oldCtl = r.controls[clientId]</span><br><span class="line">	<span class="keyword">if</span> oldCtl != <span class="literal">nil</span> &#123;</span><br><span class="line">		oldCtl.Replaced(ctl)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.controls[clientId] = ctl</span><br><span class="line">	r.Info(<span class="string">"Registered control with id %s"</span>, clientId)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="退出流程"><a href="#退出流程" class="headerlink" title="退出流程"></a>退出流程</h3><p><strong>退出流程可以考虑用<a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">https://golang.org/pkg/context/</a>简化下</strong>，这里用到了一个util.Shutdown的工具库（src/github.com/qjw/ngrok/src/ngrok/util/shutdown.go）。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Control <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of writer()</span></span><br><span class="line">	writerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of reader()</span></span><br><span class="line">	readerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controlled shutdown of manager()</span></span><br><span class="line">	managerShutdown *util.Shutdown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronizer for controller shutdown of entire Control</span></span><br><span class="line">	shutdown *util.Shutdown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">reader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// kill everything if the reader stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line">	<span class="comment">// notify that we're done</span></span><br><span class="line">	<span class="keyword">defer</span> c.readerShutdown.Complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// kill everything if the writer() stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that we've flushed all messages</span></span><br><span class="line">	<span class="keyword">defer</span> c.writerShutdown.Complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// kill everything if the control manager stops</span></span><br><span class="line">	<span class="keyword">defer</span> c.shutdown.Begin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notify that manager() has shutdown</span></span><br><span class="line">	<span class="keyword">defer</span> c.managerShutdown.Complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个专门的goruntune来监听退出<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">stopper</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 等待</span></span><br><span class="line">	c.shutdown.WaitBegin()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注销controller</span></span><br><span class="line">	controlRegistry.Del(c.id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待各种子goruntune注销</span></span><br><span class="line">	<span class="comment">// close会触发其他的goruntune退出</span></span><br><span class="line">	<span class="built_in">close</span>(c.in)</span><br><span class="line">	c.managerShutdown.WaitComplete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shutdown writer()</span></span><br><span class="line">	<span class="built_in">close</span>(c.out)</span><br><span class="line">	c.writerShutdown.WaitComplete()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭空置连接</span></span><br><span class="line">	c.conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭各种tunnel</span></span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> c.tunnels &#123;</span><br><span class="line">		<span class="comment">// 调用shutdown，</span></span><br><span class="line">		t.Shutdown()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭各种proxy连接</span></span><br><span class="line">	<span class="built_in">close</span>(c.proxies)</span><br><span class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> c.proxies &#123;</span><br><span class="line">		p.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终关闭</span></span><br><span class="line">	c.shutdown.Complete()</span><br><span class="line">	c.conn.Info(<span class="string">"Shutdown complete"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tunnel注册"><a href="#Tunnel注册" class="headerlink" title="Tunnel注册"></a>Tunnel注册</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register a new tunnel on this control connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">registerTunnel</span><span class="params">(rawTunnelReq *msg.ReqTunnel)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 若有多个tunnel，可以用一个报文一次性注册</span></span><br><span class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> strings.Split(rawTunnelReq.Protocol, <span class="string">"+"</span>) &#123;</span><br><span class="line">		tunnelReq := *rawTunnelReq</span><br><span class="line">		tunnelReq.Protocol = proto</span><br><span class="line"></span><br><span class="line">		c.conn.Debug(<span class="string">"Registering new tunnel"</span>)</span><br><span class="line">		t, err := NewTunnel(&amp;tunnelReq, c)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 回复注册失败确认</span></span><br><span class="line">			c.out &lt;- &amp;msg.NewTunnel&#123;Error: err.Error()&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注册到controller</span></span><br><span class="line">		c.tunnels = <span class="built_in">append</span>(c.tunnels, t)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回复注册成功确认</span></span><br><span class="line">		c.out &lt;- &amp;msg.NewTunnel&#123;</span><br><span class="line">			Url:	  t.url,</span><br><span class="line">			Protocol: proto,</span><br><span class="line">			ReqId:	rawTunnelReq.ReqId,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rawTunnelReq.Hostname = strings.Replace(t.url, proto+<span class="string">"://"</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的注册报文<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"ReqTunnel"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"ReqId"</span>: <span class="string">"dd1819bd088d7675"</span>,</span><br><span class="line">	<span class="attr">"Protocol"</span>: <span class="string">"http"</span>,</span><br><span class="line">	<span class="attr">"Hostname"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"Subdomain"</span>: <span class="string">"qjw"</span>,</span><br><span class="line">	<span class="attr">"HttpAuth"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"RemotePort"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Type"</span>: <span class="string">"NewTunnel"</span>,</span><br><span class="line">  <span class="attr">"Payload"</span>: &#123;</span><br><span class="line">	<span class="attr">"ReqId"</span>: <span class="string">"dd1819bd088d7675"</span>,</span><br><span class="line">	<span class="attr">"Url"</span>: <span class="string">"http://qjw.ngrok.com:10080"</span>,</span><br><span class="line">	<span class="attr">"Protocol"</span>: <span class="string">"http"</span>,</span><br><span class="line">	<span class="attr">"Error"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new tunnel from a registration message received</span></span><br><span class="line"><span class="comment">// on a control channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTunnel</span><span class="params">(m *msg.ReqTunnel, ctl *Control)</span> <span class="params">(t *Tunnel, err error)</span></span> &#123;</span><br><span class="line">	t = &amp;Tunnel&#123;</span><br><span class="line">		req:	m,</span><br><span class="line">		start:  time.Now(),</span><br><span class="line">		ctl:	ctl,</span><br><span class="line">		Logger: log.NewPrefixLogger(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proto := t.req.Protocol</span><br><span class="line">	<span class="keyword">switch</span> proto &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"tcp"</span>:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"http"</span>, <span class="string">"https"</span>:</span><br><span class="line">		l, ok := listeners[proto]</span><br><span class="line">		<span class="comment">// 注册vhost，之所以v，是因为多个url共享同一个端口，类似于nginx的server</span></span><br><span class="line">		<span class="keyword">if</span> err = registerVhost(t, proto, l.Addr.(*net.TCPAddr).Port); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	t.AddLogPrefix(t.Id())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要确认vhost的参数，最重要的host，port，这对于公网连接的请求路由至关重要<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultPortMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"http"</span>:  <span class="number">80</span>,</span><br><span class="line">	<span class="string">"https"</span>: <span class="number">443</span>,</span><br><span class="line">	<span class="string">"smtp"</span>:  <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Common functionality for registering virtually hosted protocols</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerVhost</span><span class="params">(t *Tunnel, protocol <span class="keyword">string</span>, servingPort <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	vhost := os.Getenv(<span class="string">"VHOST"</span>)</span><br><span class="line">	<span class="keyword">if</span> vhost == <span class="string">""</span> &#123;</span><br><span class="line">		vhost = fmt.Sprintf(<span class="string">"%s:%d"</span>, opts.domain, servingPort)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Canonicalize virtual host by removing default port (e.g. :80 on HTTP)</span></span><br><span class="line">	defaultPort, ok := defaultPortMap[protocol]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Couldn't find default port for protocol %s"</span>, protocol)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移除默认的端口（比如80可以忽略，81就必须明确地出现在连接中）</span></span><br><span class="line">	defaultPortSuffix := fmt.Sprintf(<span class="string">":%d"</span>, defaultPort)</span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(vhost, defaultPortSuffix) &#123;</span><br><span class="line">		vhost = vhost[<span class="number">0</span> : <span class="built_in">len</span>(vhost)-<span class="built_in">len</span>(defaultPortSuffix)]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Canonicalize by always using lower-case</span></span><br><span class="line">	vhost = strings.ToLower(vhost)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从请求中获取host</span></span><br><span class="line">	hostname := strings.ToLower(strings.TrimSpace(t.req.Hostname))</span><br><span class="line">	<span class="keyword">if</span> hostname != <span class="string">""</span> &#123;</span><br><span class="line">		t.url = fmt.Sprintf(<span class="string">"%s://%s"</span>, protocol, hostname)</span><br><span class="line">		<span class="comment">// 注册tunnel</span></span><br><span class="line">		<span class="keyword">return</span> tunnelRegistry.Register(t.url, t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未指定host，指定了subdomain，就通过服务器启动参数domain来拼装host</span></span><br><span class="line">	subdomain := strings.ToLower(strings.TrimSpace(t.req.Subdomain))</span><br><span class="line">	<span class="keyword">if</span> subdomain != <span class="string">""</span> &#123;</span><br><span class="line">		t.url = fmt.Sprintf(<span class="string">"%s://%s.%s"</span>, protocol, subdomain, vhost)</span><br><span class="line">		<span class="comment">// 注册tunnel</span></span><br><span class="line">		<span class="keyword">return</span> tunnelRegistry.Register(t.url, t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 随机生成一个url</span></span><br><span class="line">	t.url, err = tunnelRegistry.RegisterRepeat(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s://%x.%s"</span>, protocol, rand.Int31(), vhost)</span><br><span class="line">	&#125;, t)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取消注册</span></span><br><span class="line">	tunnelRegistry.Del(t.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>在连接建立之后，服务器就会预先请求一个proxy<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"ReqProxy"</span>,<span class="attr">"Payload"</span>:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个clientid非常重要，用于关联到controller<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"Type"</span>:<span class="string">"RegProxy"</span>,<span class="attr">"Payload"</span>:&#123;<span class="attr">"ClientId"</span>:<span class="string">"8c57f5cfd5b30dc3215f740f2ad72539"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 预先申请一个proxy</span></span><br><span class="line">	c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tunnelConn conn.Conn)</span></span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msg.RegProxy:</span><br><span class="line">				<span class="comment">// 新增一个proxy</span></span><br><span class="line">				NewProxy(tunnelConn, m)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proxy并没有全局的对象来注册，而是简单地关联到controller（通过之前的clientid），具体就是通过一个带缓存的channel<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Control <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// proxy connections</span></span><br><span class="line">	proxies <span class="keyword">chan</span> conn.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">	c := &amp;Control&#123;</span><br><span class="line">		<span class="comment">// 10个元素的channel</span></span><br><span class="line">		proxies:		 <span class="built_in">make</span>(<span class="keyword">chan</span> conn.Conn, <span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxy</span><span class="params">(pxyConn conn.Conn, regPxy *msg.RegProxy)</span></span> &#123;</span><br><span class="line">	pxyConn.SetType(<span class="string">"pxy"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询controller</span></span><br><span class="line">	ctl := controlRegistry.Get(regPxy.ClientId)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册</span></span><br><span class="line">	ctl.RegisterProxy(pxyConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要获取proxy时，就直接调用下面的函数<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">GetProxy</span><span class="params">()</span> <span class="params">(proxyConn conn.Conn, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// get a proxy connection from the pool</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 直接从channel中获取</span></span><br><span class="line">	<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//  没有的话，立即请求客户端</span></span><br><span class="line">		<span class="keyword">if</span> err = util.PanicToError(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.out &lt;- &amp;msg.ReqProxy&#123;&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 继续从channle中获取</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> proxyConn, ok = &lt;-c.proxies:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				err = fmt.Errorf(<span class="string">"No proxy connections available, control is closing"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(pingTimeoutInterval):</span><br><span class="line">			err = fmt.Errorf(<span class="string">"Timeout trying to get proxy connection"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="处理公网请求"><a href="#处理公网请求" class="headerlink" title="处理公网请求"></a>处理公网请求</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// listen for http</span></span><br><span class="line">	<span class="keyword">if</span> opts.httpAddr != <span class="string">""</span> &#123;</span><br><span class="line">		listeners[<span class="string">"http"</span>] = startHttpListener(opts.httpAddr, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Listens for new http(s) connections from the public internet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHttpListener</span><span class="params">(addr <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(listener *conn.Listener)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建服务器</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> listener, err = conn.Listen(addr, <span class="string">"pub"</span>, tlsCfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proto := <span class="string">"http"</span></span><br><span class="line">	<span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">		proto = <span class="string">"https"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">"Listening for public %s connections on %v"</span>, proto, listener.Addr.String())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> conn := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">			<span class="comment">// 每个连接都会调用下面的goruntune</span></span><br><span class="line">			<span class="keyword">go</span> httpHandler(conn, proto)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(c conn.Conn, proto <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取Http头</span></span><br><span class="line">	vhostConn, err := vhost.HTTP(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Warn(<span class="string">"Failed to read valid %s request: %v"</span>, proto, err)</span><br><span class="line">		c.Write([]<span class="keyword">byte</span>(BadRequest))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取http参数</span></span><br><span class="line">	host := strings.ToLower(vhostConn.Host())</span><br><span class="line">	auth := vhostConn.Request.Header.Get(<span class="string">"Authorization"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// done reading mux data, free up the request memory</span></span><br><span class="line">	vhostConn.Free()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need to read from the vhost conn now since it mucked around reading the stream</span></span><br><span class="line">	c = conn.Wrap(vhostConn, <span class="string">"pub"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从全局的Registry中查找tunnel</span></span><br><span class="line">	tunnel := tunnelRegistry.Get(fmt.Sprintf(<span class="string">"%s://%s"</span>, proto, host))</span><br><span class="line">	<span class="keyword">if</span> tunnel == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Info(<span class="string">"No tunnel found for hostname %s"</span>, host)</span><br><span class="line">		c.Write([]<span class="keyword">byte</span>(fmt.Sprintf(NotFound, <span class="built_in">len</span>(host)+<span class="number">18</span>, host)))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查认证</span></span><br><span class="line">	<span class="keyword">if</span> tunnel.req.HttpAuth != <span class="string">""</span> &amp;&amp; auth != tunnel.req.HttpAuth &#123;</span><br><span class="line">		c.Info(<span class="string">"Authentication failed: %s"</span>, auth)</span><br><span class="line">		c.Write([]<span class="keyword">byte</span>(NotAuthorized))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据交换</span></span><br><span class="line">	tunnel.HandlePublicConnection(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Http头"><a href="#Http头" class="headerlink" title="Http头"></a>Http头</h2><p>在数据交换过程中，为了作请求路由，必须先从路由中解析Http头（不考虑tcp tunnel），然后根据http头来作数据路由，而读出来的头，也必须原原本本的下发到客户端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	initVhostBufSize = <span class="number">1024</span> <span class="comment">// allocate 1 KB up front to try to avoid resizing</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sharedConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	net.Conn			   <span class="comment">// the raw connection</span></span><br><span class="line">	vhostBuf *bytes.Buffer <span class="comment">// all of the initial data that has to be read in order to vhost a connection is saved here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newShared</span><span class="params">(conn net.Conn)</span> <span class="params">(*sharedConn, io.Reader)</span></span> &#123;</span><br><span class="line">	c := &amp;sharedConn&#123;</span><br><span class="line">		Conn:	 conn,</span><br><span class="line">		<span class="comment">// 分配一块内存，用于存储http头，以便原原本本的下发到客户端</span></span><br><span class="line">		vhostBuf: bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, initVhostBufSize)),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当从conn读取数据后，复制一份到vhostBuf</span></span><br><span class="line">	<span class="keyword">return</span> c, io.TeeReader(conn, c.vhostBuf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *sharedConn)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="comment">// 已经读取到内存中的数据已经发送完</span></span><br><span class="line">	<span class="keyword">if</span> c.vhostBuf == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Unlock()</span><br><span class="line">		<span class="keyword">return</span> c.Conn.Read(p)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优先从buf中读取</span></span><br><span class="line">	n, err = c.vhostBuf.Read(p)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// end of the request buffer</span></span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="comment">// let the request buffer get garbage collected</span></span><br><span class="line">		<span class="comment">// and make sure we don't read from it again</span></span><br><span class="line">		c.vhostBuf = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读了一半继续从con中读取</span></span><br><span class="line">		<span class="comment">// continue reading from the connection</span></span><br><span class="line">		<span class="keyword">var</span> n2 <span class="keyword">int</span></span><br><span class="line">		n2, err = c.Conn.Read(p[n:])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// update total read</span></span><br><span class="line">		n += n2</span><br><span class="line">	&#125;</span><br><span class="line">	c.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vhost.HTTP<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HTTP</span><span class="params">(conn net.Conn)</span> <span class="params">(httpConn *HTTPConn, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个tee的conn</span></span><br><span class="line">	c, rd := newShared(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析Http头，不得不说go的系统库很牛X</span></span><br><span class="line">	httpConn = &amp;HTTPConn&#123;sharedConn: c&#125;</span><br><span class="line">	<span class="keyword">if</span> httpConn.Request, err = http.ReadRequest(bufio.NewReader(rd)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// body不需要</span></span><br><span class="line">	httpConn.Request.Body.Close()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于有了sharedConn这一层封装，在数据交换时，完全可以不考虑，一部分数据已经为了解析http头而实现读取出来过的细节</p>
<h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">HandlePublicConnection</span><span class="params">(publicConn conn.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">2</span> * proxyMaxPoolSize); i++ &#123;</span><br><span class="line">		<span class="comment">// 获取一个proxy</span></span><br><span class="line">		<span class="keyword">if</span> proxyConn, err = t.ctl.GetProxy(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Warn(<span class="string">"Failed to get proxy connection: %v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自动关闭和设置属性</span></span><br><span class="line">		<span class="keyword">defer</span> proxyConn.Close()</span><br><span class="line">		t.Info(<span class="string">"Got proxy connection %s"</span>, proxyConn.Id())</span><br><span class="line">		proxyConn.AddLogPrefix(t.Id())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送数据，提示开始传输数据</span></span><br><span class="line">		startPxyMsg := &amp;msg.StartProxy&#123;</span><br><span class="line">			Url:		t.url,</span><br><span class="line">			ClientAddr: publicConn.RemoteAddr().String(),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err = msg.WriteMsg(proxyConn, startPxyMsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			proxyConn.Warn(<span class="string">"Failed to write StartProxyMessage: %v, attempt %d"</span>, err, i)</span><br><span class="line">			proxyConn.Close()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// success</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 立即申请一个新的proxy</span></span><br><span class="line">	util.PanicToError(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.ctl.out &lt;- &amp;msg.ReqProxy&#123;&#125; &#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换数据</span></span><br><span class="line">	bytesIn, bytesOut := conn.Join(publicConn, proxyConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个join实现双向的数据交换，<strong>这个地方可以做一些部分优化，直接从内核到内核传数据，参考<a href="https://linux.die.net/man/2/sendfile" target="_blank" rel="noopener">sendfile</a>、<a href="https://linux.die.net/man/2/splice" target="_blank" rel="noopener">splice</a></strong><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(c Conn, c2 Conn)</span> <span class="params">(<span class="keyword">int64</span>, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	pipe := <span class="function"><span class="keyword">func</span><span class="params">(to Conn, from Conn, bytesCopied *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> to.Close()</span><br><span class="line">		<span class="keyword">defer</span> from.Close()</span><br><span class="line">		<span class="keyword">defer</span> wait.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="comment">// 这个地方可以优化，在内部有一个应用层的buf作中转</span></span><br><span class="line">		*bytesCopied, err = io.Copy(to, from)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			from.Warn(<span class="string">"Copied %d bytes to %s before failing with error %v"</span>, *bytesCopied, to.Id(), err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			from.Debug(<span class="string">"Copied %d bytes to %s"</span>, *bytesCopied, to.Id())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wait.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">var</span> fromBytes, toBytes <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// 开启两个goruntune来实现双向交换</span></span><br><span class="line">	<span class="keyword">go</span> pipe(c, c2, &amp;fromBytes)</span><br><span class="line">	<span class="keyword">go</span> pipe(c2, c, &amp;toBytes)</span><br><span class="line">	c.Info(<span class="string">"Joined with connection %s"</span>, c2.Id())</span><br><span class="line">	wait.Wait()</span><br><span class="line">	<span class="keyword">return</span> fromBytes, toBytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="tls加密"><a href="#tls加密" class="headerlink" title="tls加密"></a>tls加密</h1><p>对于tls支持，go系统库支持的非常好，参考<a href="http://colobu.com/2016/06/07/simple-golang-tls-examples/" target="_blank" rel="noopener">http://colobu.com/2016/06/07/simple-golang-tls-examples/</a></p>
<p>ngrok有点讨巧，用系统库的工具函数在tcp裸连接做了一层包装<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(l *Listener, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听tcp端口</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明对象</span></span><br><span class="line">	l = &amp;Listener&#123;</span><br><span class="line">		Addr:  listener.Addr(),</span><br><span class="line">		Conns: <span class="built_in">make</span>(<span class="keyword">chan</span> *loggedConn),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			rawConn, err := listener.Accept()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理新连接</span></span><br><span class="line">			c := wrapConn(rawConn, typ)</span><br><span class="line">			<span class="comment">// 若指定了tls配置（https tunnel必需）</span></span><br><span class="line">			<span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 直接将原来的裸tcp conn替换成被tls包装过的conn，所有的read/write会被tls层先做加工再下发</span></span><br><span class="line">				c.Conn = tls.Server(c.Conn, tlsCfg)</span><br><span class="line">			&#125;</span><br><span class="line">			l.Conns &lt;- c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>在ngrok客户端也是同样的逻辑<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(conn *loggedConn, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rawConn net.Conn</span><br><span class="line">	<span class="keyword">if</span> rawConn, err = net.Dial(<span class="string">"tcp"</span>, addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn = wrapConn(rawConn, typ)</span><br><span class="line">	conn.Debug(<span class="string">"New connection to: %v"</span>, rawConn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若指定了tls配置（https tunnel必需）</span></span><br><span class="line">	<span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">		conn.StartTLS(tlsCfg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loggedConn)</span> <span class="title">StartTLS</span><span class="params">(tlsCfg *tls.Config)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 直接将原来的裸tcp conn替换成被tls包装过的conn，所有的read/write会被tls层先做加工再下发</span></span><br><span class="line">	c.Conn = tls.Client(c.Conn, tlsCfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://blog.kimq.cn/2017/07/05/ngrokd/" data-id="ckdbgbyxa004543pom79l223o" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
        <a href="http://blog.kimq.cn/2017/07/05/ngrokd/#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> Comments
        </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngrok/">ngrok</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/2017/07/03/golang-anonymous-member/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">Golang 匿名对象指针和对象的区别</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/2017/07/05/ngrok/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">Ngrok客户端源码学习笔记</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



        </div>
        <div class="col-sm-2 col-sm-offset-1 blog-sidebar">
          
  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Golang/">Golang</a><span class="sidebar-module-list-count">14</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Openldap/">Openldap</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Python/">Python</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/后端/">后端</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/学习笔记/">学习笔记</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/开发环境/">开发环境</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/源码学习/">源码学习</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/环境搭建/">环境搭建</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/运营运维/">运营运维</a><span class="sidebar-module-list-count">10</span><ul class="sidebar-module-list-child"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/运营运维/代理/">代理</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/运营运维/网站/">网站</a><span class="sidebar-module-list-count">1</span></li></ul></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ansible/">ansible</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/antd/">antd</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/cookie/">cookie</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/cors/">cors</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/crsf/">crsf</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/docker/">docker</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/drone/">drone</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/elasticsearch/">elasticsearch</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/flask/">flask</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/git/">git</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/github/">github</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/gitlab/">gitlab</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/golang/">golang</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/gorm/">gorm</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/grpc/">grpc</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/hexo/">hexo</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/influxdb/">influxdb</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/jsonp/">jsonp</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/jsonschema/">jsonschema</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/kibana/">kibana</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/martini/">martini</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/nginx/">nginx</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ngrok/">ngrok</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/node/">node</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/openldap/">openldap</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/pip/">pip</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/proxy/">proxy</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/python/">python</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/redis/">redis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/sentry/">sentry</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/sqlalchemy/">sqlalchemy</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ssh/">ssh</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/sso/">sso</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/tars/">tars</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/tavern/">tavern</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/travis/">travis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/uml/">uml</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/wcgi/">wcgi</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/xss/">xss</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/一致性hash/">一致性hash</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/持续集成/">持续集成</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/盗链/">盗链</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/签名/">签名</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/证书/">证书</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/antd/" style="font-size: 10px;">antd</a> <a href="/tags/cookie/" style="font-size: 11.67px;">cookie</a> <a href="/tags/cors/" style="font-size: 10px;">cors</a> <a href="/tags/crsf/" style="font-size: 10px;">crsf</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/drone/" style="font-size: 16.67px;">drone</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/flask/" style="font-size: 11.67px;">flask</a> <a href="/tags/git/" style="font-size: 11.67px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/gitlab/" style="font-size: 11.67px;">gitlab</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/gorm/" style="font-size: 10px;">gorm</a> <a href="/tags/grpc/" style="font-size: 10px;">grpc</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/influxdb/" style="font-size: 10px;">influxdb</a> <a href="/tags/jsonp/" style="font-size: 10px;">jsonp</a> <a href="/tags/jsonschema/" style="font-size: 10px;">jsonschema</a> <a href="/tags/kibana/" style="font-size: 10px;">kibana</a> <a href="/tags/martini/" style="font-size: 10px;">martini</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/ngrok/" style="font-size: 11.67px;">ngrok</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/openldap/" style="font-size: 13.33px;">openldap</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/proxy/" style="font-size: 13.33px;">proxy</a> <a href="/tags/python/" style="font-size: 11.67px;">python</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/sentry/" style="font-size: 11.67px;">sentry</a> <a href="/tags/sqlalchemy/" style="font-size: 10px;">sqlalchemy</a> <a href="/tags/ssh/" style="font-size: 11.67px;">ssh</a> <a href="/tags/sso/" style="font-size: 10px;">sso</a> <a href="/tags/tars/" style="font-size: 10px;">tars</a> <a href="/tags/tavern/" style="font-size: 10px;">tavern</a> <a href="/tags/travis/" style="font-size: 10px;">travis</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a> <a href="/tags/wcgi/" style="font-size: 10px;">wcgi</a> <a href="/tags/xss/" style="font-size: 10px;">xss</a> <a href="/tags/一致性hash/" style="font-size: 10px;">一致性hash</a> <a href="/tags/持续集成/" style="font-size: 18.33px;">持续集成</a> <a href="/tags/盗链/" style="font-size: 10px;">盗链</a> <a href="/tags/签名/" style="font-size: 11.67px;">签名</a> <a href="/tags/证书/" style="font-size: 11.67px;">证书</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/08/">八月 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">六月 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/03/">三月 2020</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">二月 2020</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/01/">一月 2020</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/04/">四月 2017</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/03/">三月 2017</a><span class="sidebar-module-list-count">10</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">二月 2017</a><span class="sidebar-module-list-count">10</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2020/08/01/gitlab-sentry/">gitlab/sentry集成</a>
        </li>
      
        <li>
          <a href="/2020/06/10/ansible/">Ansible实践</a>
        </li>
      
        <li>
          <a href="/2020/03/08/elasticsearch_basic/">ElasticSearch学习笔记</a>
        </li>
      
        <li>
          <a href="/2020/02/29/jaeger_basic/">Jaeger初探</a>
        </li>
      
        <li>
          <a href="/2020/02/20/tavern/">ResfulApi测试框架tavern</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2020 KingQiu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      <br/>
      CopyRight © 2019 <a href="http://beian.miit.gov.cn/" target="_blank">粤ICP备19068003号</a>
    </div>
  </div>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  
<script>
  var disqus_shortname = 'blog-qiujinwu-com';
  
  var disqus_url = 'http://blog.kimq.cn/2017/07/05/ngrokd/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js" crossorigin="anonymous"></script>

<script src="http://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
